// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
	"github.com/jackc/pgx/v5/pgxpool"
)

// PostgresMock implements repo.postgres
type PostgresMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcExec          func(ctx context.Context, query string, args ...any) (c2 pgconn.CommandTag, err error)
	inspectFuncExec   func(ctx context.Context, query string, args ...any)
	afterExecCounter  uint64
	beforeExecCounter uint64
	ExecMock          mPostgresMockExec

	funcGet          func(ctx context.Context, dest any, query string, args ...any) (err error)
	inspectFuncGet   func(ctx context.Context, dest any, query string, args ...any)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mPostgresMockGet

	funcGetPool          func(ctx context.Context) (pp1 *pgxpool.Pool)
	inspectFuncGetPool   func(ctx context.Context)
	afterGetPoolCounter  uint64
	beforeGetPoolCounter uint64
	GetPoolMock          mPostgresMockGetPool

	funcQuery          func(ctx context.Context, query string) (r1 pgx.Rows, err error)
	inspectFuncQuery   func(ctx context.Context, query string)
	afterQueryCounter  uint64
	beforeQueryCounter uint64
	QueryMock          mPostgresMockQuery

	funcQueryRow          func(ctx context.Context, query string, args ...any) (r1 pgx.Row)
	inspectFuncQueryRow   func(ctx context.Context, query string, args ...any)
	afterQueryRowCounter  uint64
	beforeQueryRowCounter uint64
	QueryRowMock          mPostgresMockQueryRow

	funcSelect          func(ctx context.Context, dest any, query string, args ...any) (err error)
	inspectFuncSelect   func(ctx context.Context, dest any, query string, args ...any)
	afterSelectCounter  uint64
	beforeSelectCounter uint64
	SelectMock          mPostgresMockSelect
}

// NewPostgresMock returns a mock for repo.postgres
func NewPostgresMock(t minimock.Tester) *PostgresMock {
	m := &PostgresMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ExecMock = mPostgresMockExec{mock: m}
	m.ExecMock.callArgs = []*PostgresMockExecParams{}

	m.GetMock = mPostgresMockGet{mock: m}
	m.GetMock.callArgs = []*PostgresMockGetParams{}

	m.GetPoolMock = mPostgresMockGetPool{mock: m}
	m.GetPoolMock.callArgs = []*PostgresMockGetPoolParams{}

	m.QueryMock = mPostgresMockQuery{mock: m}
	m.QueryMock.callArgs = []*PostgresMockQueryParams{}

	m.QueryRowMock = mPostgresMockQueryRow{mock: m}
	m.QueryRowMock.callArgs = []*PostgresMockQueryRowParams{}

	m.SelectMock = mPostgresMockSelect{mock: m}
	m.SelectMock.callArgs = []*PostgresMockSelectParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPostgresMockExec struct {
	mock               *PostgresMock
	defaultExpectation *PostgresMockExecExpectation
	expectations       []*PostgresMockExecExpectation

	callArgs []*PostgresMockExecParams
	mutex    sync.RWMutex
}

// PostgresMockExecExpectation specifies expectation struct of the postgres.Exec
type PostgresMockExecExpectation struct {
	mock    *PostgresMock
	params  *PostgresMockExecParams
	results *PostgresMockExecResults
	Counter uint64
}

// PostgresMockExecParams contains parameters of the postgres.Exec
type PostgresMockExecParams struct {
	ctx   context.Context
	query string
	args  []any
}

// PostgresMockExecResults contains results of the postgres.Exec
type PostgresMockExecResults struct {
	c2  pgconn.CommandTag
	err error
}

// Expect sets up expected params for postgres.Exec
func (mmExec *mPostgresMockExec) Expect(ctx context.Context, query string, args ...any) *mPostgresMockExec {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &PostgresMockExecExpectation{}
	}

	mmExec.defaultExpectation.params = &PostgresMockExecParams{ctx, query, args}
	for _, e := range mmExec.expectations {
		if minimock.Equal(e.params, mmExec.defaultExpectation.params) {
			mmExec.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmExec.defaultExpectation.params)
		}
	}

	return mmExec
}

// Inspect accepts an inspector function that has same arguments as the postgres.Exec
func (mmExec *mPostgresMockExec) Inspect(f func(ctx context.Context, query string, args ...any)) *mPostgresMockExec {
	if mmExec.mock.inspectFuncExec != nil {
		mmExec.mock.t.Fatalf("Inspect function is already set for PostgresMock.Exec")
	}

	mmExec.mock.inspectFuncExec = f

	return mmExec
}

// Return sets up results that will be returned by postgres.Exec
func (mmExec *mPostgresMockExec) Return(c2 pgconn.CommandTag, err error) *PostgresMock {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresMock.Exec mock is already set by Set")
	}

	if mmExec.defaultExpectation == nil {
		mmExec.defaultExpectation = &PostgresMockExecExpectation{mock: mmExec.mock}
	}
	mmExec.defaultExpectation.results = &PostgresMockExecResults{c2, err}
	return mmExec.mock
}

// Set uses given function f to mock the postgres.Exec method
func (mmExec *mPostgresMockExec) Set(f func(ctx context.Context, query string, args ...any) (c2 pgconn.CommandTag, err error)) *PostgresMock {
	if mmExec.defaultExpectation != nil {
		mmExec.mock.t.Fatalf("Default expectation is already set for the postgres.Exec method")
	}

	if len(mmExec.expectations) > 0 {
		mmExec.mock.t.Fatalf("Some expectations are already set for the postgres.Exec method")
	}

	mmExec.mock.funcExec = f
	return mmExec.mock
}

// When sets expectation for the postgres.Exec which will trigger the result defined by the following
// Then helper
func (mmExec *mPostgresMockExec) When(ctx context.Context, query string, args ...any) *PostgresMockExecExpectation {
	if mmExec.mock.funcExec != nil {
		mmExec.mock.t.Fatalf("PostgresMock.Exec mock is already set by Set")
	}

	expectation := &PostgresMockExecExpectation{
		mock:   mmExec.mock,
		params: &PostgresMockExecParams{ctx, query, args},
	}
	mmExec.expectations = append(mmExec.expectations, expectation)
	return expectation
}

// Then sets up postgres.Exec return parameters for the expectation previously defined by the When method
func (e *PostgresMockExecExpectation) Then(c2 pgconn.CommandTag, err error) *PostgresMock {
	e.results = &PostgresMockExecResults{c2, err}
	return e.mock
}

// Exec implements repo.postgres
func (mmExec *PostgresMock) Exec(ctx context.Context, query string, args ...any) (c2 pgconn.CommandTag, err error) {
	mm_atomic.AddUint64(&mmExec.beforeExecCounter, 1)
	defer mm_atomic.AddUint64(&mmExec.afterExecCounter, 1)

	if mmExec.inspectFuncExec != nil {
		mmExec.inspectFuncExec(ctx, query, args...)
	}

	mm_params := PostgresMockExecParams{ctx, query, args}

	// Record call args
	mmExec.ExecMock.mutex.Lock()
	mmExec.ExecMock.callArgs = append(mmExec.ExecMock.callArgs, &mm_params)
	mmExec.ExecMock.mutex.Unlock()

	for _, e := range mmExec.ExecMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.c2, e.results.err
		}
	}

	if mmExec.ExecMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmExec.ExecMock.defaultExpectation.Counter, 1)
		mm_want := mmExec.ExecMock.defaultExpectation.params
		mm_got := PostgresMockExecParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmExec.t.Errorf("PostgresMock.Exec got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmExec.ExecMock.defaultExpectation.results
		if mm_results == nil {
			mmExec.t.Fatal("No results are set for the PostgresMock.Exec")
		}
		return (*mm_results).c2, (*mm_results).err
	}
	if mmExec.funcExec != nil {
		return mmExec.funcExec(ctx, query, args...)
	}
	mmExec.t.Fatalf("Unexpected call to PostgresMock.Exec. %v %v %v", ctx, query, args)
	return
}

// ExecAfterCounter returns a count of finished PostgresMock.Exec invocations
func (mmExec *PostgresMock) ExecAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.afterExecCounter)
}

// ExecBeforeCounter returns a count of PostgresMock.Exec invocations
func (mmExec *PostgresMock) ExecBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmExec.beforeExecCounter)
}

// Calls returns a list of arguments used in each call to PostgresMock.Exec.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmExec *mPostgresMockExec) Calls() []*PostgresMockExecParams {
	mmExec.mutex.RLock()

	argCopy := make([]*PostgresMockExecParams, len(mmExec.callArgs))
	copy(argCopy, mmExec.callArgs)

	mmExec.mutex.RUnlock()

	return argCopy
}

// MinimockExecDone returns true if the count of the Exec invocations corresponds
// the number of defined expectations
func (m *PostgresMock) MinimockExecDone() bool {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		return false
	}
	return true
}

// MinimockExecInspect logs each unmet expectation
func (m *PostgresMock) MinimockExecInspect() {
	for _, e := range m.ExecMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresMock.Exec with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ExecMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		if m.ExecMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostgresMock.Exec")
		} else {
			m.t.Errorf("Expected call to PostgresMock.Exec with params: %#v", *m.ExecMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcExec != nil && mm_atomic.LoadUint64(&m.afterExecCounter) < 1 {
		m.t.Error("Expected call to PostgresMock.Exec")
	}
}

type mPostgresMockGet struct {
	mock               *PostgresMock
	defaultExpectation *PostgresMockGetExpectation
	expectations       []*PostgresMockGetExpectation

	callArgs []*PostgresMockGetParams
	mutex    sync.RWMutex
}

// PostgresMockGetExpectation specifies expectation struct of the postgres.Get
type PostgresMockGetExpectation struct {
	mock    *PostgresMock
	params  *PostgresMockGetParams
	results *PostgresMockGetResults
	Counter uint64
}

// PostgresMockGetParams contains parameters of the postgres.Get
type PostgresMockGetParams struct {
	ctx   context.Context
	dest  any
	query string
	args  []any
}

// PostgresMockGetResults contains results of the postgres.Get
type PostgresMockGetResults struct {
	err error
}

// Expect sets up expected params for postgres.Get
func (mmGet *mPostgresMockGet) Expect(ctx context.Context, dest any, query string, args ...any) *mPostgresMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PostgresMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &PostgresMockGetParams{ctx, dest, query, args}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the postgres.Get
func (mmGet *mPostgresMockGet) Inspect(f func(ctx context.Context, dest any, query string, args ...any)) *mPostgresMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for PostgresMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by postgres.Get
func (mmGet *mPostgresMockGet) Return(err error) *PostgresMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &PostgresMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &PostgresMockGetResults{err}
	return mmGet.mock
}

// Set uses given function f to mock the postgres.Get method
func (mmGet *mPostgresMockGet) Set(f func(ctx context.Context, dest any, query string, args ...any) (err error)) *PostgresMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the postgres.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the postgres.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the postgres.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mPostgresMockGet) When(ctx context.Context, dest any, query string, args ...any) *PostgresMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("PostgresMock.Get mock is already set by Set")
	}

	expectation := &PostgresMockGetExpectation{
		mock:   mmGet.mock,
		params: &PostgresMockGetParams{ctx, dest, query, args},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up postgres.Get return parameters for the expectation previously defined by the When method
func (e *PostgresMockGetExpectation) Then(err error) *PostgresMock {
	e.results = &PostgresMockGetResults{err}
	return e.mock
}

// Get implements repo.postgres
func (mmGet *PostgresMock) Get(ctx context.Context, dest any, query string, args ...any) (err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, dest, query, args...)
	}

	mm_params := PostgresMockGetParams{ctx, dest, query, args}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, &mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := PostgresMockGetParams{ctx, dest, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("PostgresMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the PostgresMock.Get")
		}
		return (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, dest, query, args...)
	}
	mmGet.t.Fatalf("Unexpected call to PostgresMock.Get. %v %v %v %v", ctx, dest, query, args)
	return
}

// GetAfterCounter returns a count of finished PostgresMock.Get invocations
func (mmGet *PostgresMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of PostgresMock.Get invocations
func (mmGet *PostgresMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to PostgresMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mPostgresMockGet) Calls() []*PostgresMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*PostgresMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *PostgresMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *PostgresMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostgresMock.Get")
		} else {
			m.t.Errorf("Expected call to PostgresMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to PostgresMock.Get")
	}
}

type mPostgresMockGetPool struct {
	mock               *PostgresMock
	defaultExpectation *PostgresMockGetPoolExpectation
	expectations       []*PostgresMockGetPoolExpectation

	callArgs []*PostgresMockGetPoolParams
	mutex    sync.RWMutex
}

// PostgresMockGetPoolExpectation specifies expectation struct of the postgres.GetPool
type PostgresMockGetPoolExpectation struct {
	mock    *PostgresMock
	params  *PostgresMockGetPoolParams
	results *PostgresMockGetPoolResults
	Counter uint64
}

// PostgresMockGetPoolParams contains parameters of the postgres.GetPool
type PostgresMockGetPoolParams struct {
	ctx context.Context
}

// PostgresMockGetPoolResults contains results of the postgres.GetPool
type PostgresMockGetPoolResults struct {
	pp1 *pgxpool.Pool
}

// Expect sets up expected params for postgres.GetPool
func (mmGetPool *mPostgresMockGetPool) Expect(ctx context.Context) *mPostgresMockGetPool {
	if mmGetPool.mock.funcGetPool != nil {
		mmGetPool.mock.t.Fatalf("PostgresMock.GetPool mock is already set by Set")
	}

	if mmGetPool.defaultExpectation == nil {
		mmGetPool.defaultExpectation = &PostgresMockGetPoolExpectation{}
	}

	mmGetPool.defaultExpectation.params = &PostgresMockGetPoolParams{ctx}
	for _, e := range mmGetPool.expectations {
		if minimock.Equal(e.params, mmGetPool.defaultExpectation.params) {
			mmGetPool.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPool.defaultExpectation.params)
		}
	}

	return mmGetPool
}

// Inspect accepts an inspector function that has same arguments as the postgres.GetPool
func (mmGetPool *mPostgresMockGetPool) Inspect(f func(ctx context.Context)) *mPostgresMockGetPool {
	if mmGetPool.mock.inspectFuncGetPool != nil {
		mmGetPool.mock.t.Fatalf("Inspect function is already set for PostgresMock.GetPool")
	}

	mmGetPool.mock.inspectFuncGetPool = f

	return mmGetPool
}

// Return sets up results that will be returned by postgres.GetPool
func (mmGetPool *mPostgresMockGetPool) Return(pp1 *pgxpool.Pool) *PostgresMock {
	if mmGetPool.mock.funcGetPool != nil {
		mmGetPool.mock.t.Fatalf("PostgresMock.GetPool mock is already set by Set")
	}

	if mmGetPool.defaultExpectation == nil {
		mmGetPool.defaultExpectation = &PostgresMockGetPoolExpectation{mock: mmGetPool.mock}
	}
	mmGetPool.defaultExpectation.results = &PostgresMockGetPoolResults{pp1}
	return mmGetPool.mock
}

// Set uses given function f to mock the postgres.GetPool method
func (mmGetPool *mPostgresMockGetPool) Set(f func(ctx context.Context) (pp1 *pgxpool.Pool)) *PostgresMock {
	if mmGetPool.defaultExpectation != nil {
		mmGetPool.mock.t.Fatalf("Default expectation is already set for the postgres.GetPool method")
	}

	if len(mmGetPool.expectations) > 0 {
		mmGetPool.mock.t.Fatalf("Some expectations are already set for the postgres.GetPool method")
	}

	mmGetPool.mock.funcGetPool = f
	return mmGetPool.mock
}

// When sets expectation for the postgres.GetPool which will trigger the result defined by the following
// Then helper
func (mmGetPool *mPostgresMockGetPool) When(ctx context.Context) *PostgresMockGetPoolExpectation {
	if mmGetPool.mock.funcGetPool != nil {
		mmGetPool.mock.t.Fatalf("PostgresMock.GetPool mock is already set by Set")
	}

	expectation := &PostgresMockGetPoolExpectation{
		mock:   mmGetPool.mock,
		params: &PostgresMockGetPoolParams{ctx},
	}
	mmGetPool.expectations = append(mmGetPool.expectations, expectation)
	return expectation
}

// Then sets up postgres.GetPool return parameters for the expectation previously defined by the When method
func (e *PostgresMockGetPoolExpectation) Then(pp1 *pgxpool.Pool) *PostgresMock {
	e.results = &PostgresMockGetPoolResults{pp1}
	return e.mock
}

// GetPool implements repo.postgres
func (mmGetPool *PostgresMock) GetPool(ctx context.Context) (pp1 *pgxpool.Pool) {
	mm_atomic.AddUint64(&mmGetPool.beforeGetPoolCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPool.afterGetPoolCounter, 1)

	if mmGetPool.inspectFuncGetPool != nil {
		mmGetPool.inspectFuncGetPool(ctx)
	}

	mm_params := PostgresMockGetPoolParams{ctx}

	// Record call args
	mmGetPool.GetPoolMock.mutex.Lock()
	mmGetPool.GetPoolMock.callArgs = append(mmGetPool.GetPoolMock.callArgs, &mm_params)
	mmGetPool.GetPoolMock.mutex.Unlock()

	for _, e := range mmGetPool.GetPoolMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1
		}
	}

	if mmGetPool.GetPoolMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPool.GetPoolMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPool.GetPoolMock.defaultExpectation.params
		mm_got := PostgresMockGetPoolParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPool.t.Errorf("PostgresMock.GetPool got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPool.GetPoolMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPool.t.Fatal("No results are set for the PostgresMock.GetPool")
		}
		return (*mm_results).pp1
	}
	if mmGetPool.funcGetPool != nil {
		return mmGetPool.funcGetPool(ctx)
	}
	mmGetPool.t.Fatalf("Unexpected call to PostgresMock.GetPool. %v", ctx)
	return
}

// GetPoolAfterCounter returns a count of finished PostgresMock.GetPool invocations
func (mmGetPool *PostgresMock) GetPoolAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPool.afterGetPoolCounter)
}

// GetPoolBeforeCounter returns a count of PostgresMock.GetPool invocations
func (mmGetPool *PostgresMock) GetPoolBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPool.beforeGetPoolCounter)
}

// Calls returns a list of arguments used in each call to PostgresMock.GetPool.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPool *mPostgresMockGetPool) Calls() []*PostgresMockGetPoolParams {
	mmGetPool.mutex.RLock()

	argCopy := make([]*PostgresMockGetPoolParams, len(mmGetPool.callArgs))
	copy(argCopy, mmGetPool.callArgs)

	mmGetPool.mutex.RUnlock()

	return argCopy
}

// MinimockGetPoolDone returns true if the count of the GetPool invocations corresponds
// the number of defined expectations
func (m *PostgresMock) MinimockGetPoolDone() bool {
	for _, e := range m.GetPoolMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPoolMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPoolCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPool != nil && mm_atomic.LoadUint64(&m.afterGetPoolCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPoolInspect logs each unmet expectation
func (m *PostgresMock) MinimockGetPoolInspect() {
	for _, e := range m.GetPoolMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresMock.GetPool with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPoolMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPoolCounter) < 1 {
		if m.GetPoolMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostgresMock.GetPool")
		} else {
			m.t.Errorf("Expected call to PostgresMock.GetPool with params: %#v", *m.GetPoolMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPool != nil && mm_atomic.LoadUint64(&m.afterGetPoolCounter) < 1 {
		m.t.Error("Expected call to PostgresMock.GetPool")
	}
}

type mPostgresMockQuery struct {
	mock               *PostgresMock
	defaultExpectation *PostgresMockQueryExpectation
	expectations       []*PostgresMockQueryExpectation

	callArgs []*PostgresMockQueryParams
	mutex    sync.RWMutex
}

// PostgresMockQueryExpectation specifies expectation struct of the postgres.Query
type PostgresMockQueryExpectation struct {
	mock    *PostgresMock
	params  *PostgresMockQueryParams
	results *PostgresMockQueryResults
	Counter uint64
}

// PostgresMockQueryParams contains parameters of the postgres.Query
type PostgresMockQueryParams struct {
	ctx   context.Context
	query string
}

// PostgresMockQueryResults contains results of the postgres.Query
type PostgresMockQueryResults struct {
	r1  pgx.Rows
	err error
}

// Expect sets up expected params for postgres.Query
func (mmQuery *mPostgresMockQuery) Expect(ctx context.Context, query string) *mPostgresMockQuery {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &PostgresMockQueryExpectation{}
	}

	mmQuery.defaultExpectation.params = &PostgresMockQueryParams{ctx, query}
	for _, e := range mmQuery.expectations {
		if minimock.Equal(e.params, mmQuery.defaultExpectation.params) {
			mmQuery.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQuery.defaultExpectation.params)
		}
	}

	return mmQuery
}

// Inspect accepts an inspector function that has same arguments as the postgres.Query
func (mmQuery *mPostgresMockQuery) Inspect(f func(ctx context.Context, query string)) *mPostgresMockQuery {
	if mmQuery.mock.inspectFuncQuery != nil {
		mmQuery.mock.t.Fatalf("Inspect function is already set for PostgresMock.Query")
	}

	mmQuery.mock.inspectFuncQuery = f

	return mmQuery
}

// Return sets up results that will be returned by postgres.Query
func (mmQuery *mPostgresMockQuery) Return(r1 pgx.Rows, err error) *PostgresMock {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresMock.Query mock is already set by Set")
	}

	if mmQuery.defaultExpectation == nil {
		mmQuery.defaultExpectation = &PostgresMockQueryExpectation{mock: mmQuery.mock}
	}
	mmQuery.defaultExpectation.results = &PostgresMockQueryResults{r1, err}
	return mmQuery.mock
}

// Set uses given function f to mock the postgres.Query method
func (mmQuery *mPostgresMockQuery) Set(f func(ctx context.Context, query string) (r1 pgx.Rows, err error)) *PostgresMock {
	if mmQuery.defaultExpectation != nil {
		mmQuery.mock.t.Fatalf("Default expectation is already set for the postgres.Query method")
	}

	if len(mmQuery.expectations) > 0 {
		mmQuery.mock.t.Fatalf("Some expectations are already set for the postgres.Query method")
	}

	mmQuery.mock.funcQuery = f
	return mmQuery.mock
}

// When sets expectation for the postgres.Query which will trigger the result defined by the following
// Then helper
func (mmQuery *mPostgresMockQuery) When(ctx context.Context, query string) *PostgresMockQueryExpectation {
	if mmQuery.mock.funcQuery != nil {
		mmQuery.mock.t.Fatalf("PostgresMock.Query mock is already set by Set")
	}

	expectation := &PostgresMockQueryExpectation{
		mock:   mmQuery.mock,
		params: &PostgresMockQueryParams{ctx, query},
	}
	mmQuery.expectations = append(mmQuery.expectations, expectation)
	return expectation
}

// Then sets up postgres.Query return parameters for the expectation previously defined by the When method
func (e *PostgresMockQueryExpectation) Then(r1 pgx.Rows, err error) *PostgresMock {
	e.results = &PostgresMockQueryResults{r1, err}
	return e.mock
}

// Query implements repo.postgres
func (mmQuery *PostgresMock) Query(ctx context.Context, query string) (r1 pgx.Rows, err error) {
	mm_atomic.AddUint64(&mmQuery.beforeQueryCounter, 1)
	defer mm_atomic.AddUint64(&mmQuery.afterQueryCounter, 1)

	if mmQuery.inspectFuncQuery != nil {
		mmQuery.inspectFuncQuery(ctx, query)
	}

	mm_params := PostgresMockQueryParams{ctx, query}

	// Record call args
	mmQuery.QueryMock.mutex.Lock()
	mmQuery.QueryMock.callArgs = append(mmQuery.QueryMock.callArgs, &mm_params)
	mmQuery.QueryMock.mutex.Unlock()

	for _, e := range mmQuery.QueryMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmQuery.QueryMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQuery.QueryMock.defaultExpectation.Counter, 1)
		mm_want := mmQuery.QueryMock.defaultExpectation.params
		mm_got := PostgresMockQueryParams{ctx, query}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQuery.t.Errorf("PostgresMock.Query got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQuery.QueryMock.defaultExpectation.results
		if mm_results == nil {
			mmQuery.t.Fatal("No results are set for the PostgresMock.Query")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmQuery.funcQuery != nil {
		return mmQuery.funcQuery(ctx, query)
	}
	mmQuery.t.Fatalf("Unexpected call to PostgresMock.Query. %v %v", ctx, query)
	return
}

// QueryAfterCounter returns a count of finished PostgresMock.Query invocations
func (mmQuery *PostgresMock) QueryAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.afterQueryCounter)
}

// QueryBeforeCounter returns a count of PostgresMock.Query invocations
func (mmQuery *PostgresMock) QueryBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQuery.beforeQueryCounter)
}

// Calls returns a list of arguments used in each call to PostgresMock.Query.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQuery *mPostgresMockQuery) Calls() []*PostgresMockQueryParams {
	mmQuery.mutex.RLock()

	argCopy := make([]*PostgresMockQueryParams, len(mmQuery.callArgs))
	copy(argCopy, mmQuery.callArgs)

	mmQuery.mutex.RUnlock()

	return argCopy
}

// MinimockQueryDone returns true if the count of the Query invocations corresponds
// the number of defined expectations
func (m *PostgresMock) MinimockQueryDone() bool {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryInspect logs each unmet expectation
func (m *PostgresMock) MinimockQueryInspect() {
	for _, e := range m.QueryMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresMock.Query with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		if m.QueryMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostgresMock.Query")
		} else {
			m.t.Errorf("Expected call to PostgresMock.Query with params: %#v", *m.QueryMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQuery != nil && mm_atomic.LoadUint64(&m.afterQueryCounter) < 1 {
		m.t.Error("Expected call to PostgresMock.Query")
	}
}

type mPostgresMockQueryRow struct {
	mock               *PostgresMock
	defaultExpectation *PostgresMockQueryRowExpectation
	expectations       []*PostgresMockQueryRowExpectation

	callArgs []*PostgresMockQueryRowParams
	mutex    sync.RWMutex
}

// PostgresMockQueryRowExpectation specifies expectation struct of the postgres.QueryRow
type PostgresMockQueryRowExpectation struct {
	mock    *PostgresMock
	params  *PostgresMockQueryRowParams
	results *PostgresMockQueryRowResults
	Counter uint64
}

// PostgresMockQueryRowParams contains parameters of the postgres.QueryRow
type PostgresMockQueryRowParams struct {
	ctx   context.Context
	query string
	args  []any
}

// PostgresMockQueryRowResults contains results of the postgres.QueryRow
type PostgresMockQueryRowResults struct {
	r1 pgx.Row
}

// Expect sets up expected params for postgres.QueryRow
func (mmQueryRow *mPostgresMockQueryRow) Expect(ctx context.Context, query string, args ...any) *mPostgresMockQueryRow {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("PostgresMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &PostgresMockQueryRowExpectation{}
	}

	mmQueryRow.defaultExpectation.params = &PostgresMockQueryRowParams{ctx, query, args}
	for _, e := range mmQueryRow.expectations {
		if minimock.Equal(e.params, mmQueryRow.defaultExpectation.params) {
			mmQueryRow.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmQueryRow.defaultExpectation.params)
		}
	}

	return mmQueryRow
}

// Inspect accepts an inspector function that has same arguments as the postgres.QueryRow
func (mmQueryRow *mPostgresMockQueryRow) Inspect(f func(ctx context.Context, query string, args ...any)) *mPostgresMockQueryRow {
	if mmQueryRow.mock.inspectFuncQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("Inspect function is already set for PostgresMock.QueryRow")
	}

	mmQueryRow.mock.inspectFuncQueryRow = f

	return mmQueryRow
}

// Return sets up results that will be returned by postgres.QueryRow
func (mmQueryRow *mPostgresMockQueryRow) Return(r1 pgx.Row) *PostgresMock {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("PostgresMock.QueryRow mock is already set by Set")
	}

	if mmQueryRow.defaultExpectation == nil {
		mmQueryRow.defaultExpectation = &PostgresMockQueryRowExpectation{mock: mmQueryRow.mock}
	}
	mmQueryRow.defaultExpectation.results = &PostgresMockQueryRowResults{r1}
	return mmQueryRow.mock
}

// Set uses given function f to mock the postgres.QueryRow method
func (mmQueryRow *mPostgresMockQueryRow) Set(f func(ctx context.Context, query string, args ...any) (r1 pgx.Row)) *PostgresMock {
	if mmQueryRow.defaultExpectation != nil {
		mmQueryRow.mock.t.Fatalf("Default expectation is already set for the postgres.QueryRow method")
	}

	if len(mmQueryRow.expectations) > 0 {
		mmQueryRow.mock.t.Fatalf("Some expectations are already set for the postgres.QueryRow method")
	}

	mmQueryRow.mock.funcQueryRow = f
	return mmQueryRow.mock
}

// When sets expectation for the postgres.QueryRow which will trigger the result defined by the following
// Then helper
func (mmQueryRow *mPostgresMockQueryRow) When(ctx context.Context, query string, args ...any) *PostgresMockQueryRowExpectation {
	if mmQueryRow.mock.funcQueryRow != nil {
		mmQueryRow.mock.t.Fatalf("PostgresMock.QueryRow mock is already set by Set")
	}

	expectation := &PostgresMockQueryRowExpectation{
		mock:   mmQueryRow.mock,
		params: &PostgresMockQueryRowParams{ctx, query, args},
	}
	mmQueryRow.expectations = append(mmQueryRow.expectations, expectation)
	return expectation
}

// Then sets up postgres.QueryRow return parameters for the expectation previously defined by the When method
func (e *PostgresMockQueryRowExpectation) Then(r1 pgx.Row) *PostgresMock {
	e.results = &PostgresMockQueryRowResults{r1}
	return e.mock
}

// QueryRow implements repo.postgres
func (mmQueryRow *PostgresMock) QueryRow(ctx context.Context, query string, args ...any) (r1 pgx.Row) {
	mm_atomic.AddUint64(&mmQueryRow.beforeQueryRowCounter, 1)
	defer mm_atomic.AddUint64(&mmQueryRow.afterQueryRowCounter, 1)

	if mmQueryRow.inspectFuncQueryRow != nil {
		mmQueryRow.inspectFuncQueryRow(ctx, query, args...)
	}

	mm_params := PostgresMockQueryRowParams{ctx, query, args}

	// Record call args
	mmQueryRow.QueryRowMock.mutex.Lock()
	mmQueryRow.QueryRowMock.callArgs = append(mmQueryRow.QueryRowMock.callArgs, &mm_params)
	mmQueryRow.QueryRowMock.mutex.Unlock()

	for _, e := range mmQueryRow.QueryRowMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1
		}
	}

	if mmQueryRow.QueryRowMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmQueryRow.QueryRowMock.defaultExpectation.Counter, 1)
		mm_want := mmQueryRow.QueryRowMock.defaultExpectation.params
		mm_got := PostgresMockQueryRowParams{ctx, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmQueryRow.t.Errorf("PostgresMock.QueryRow got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmQueryRow.QueryRowMock.defaultExpectation.results
		if mm_results == nil {
			mmQueryRow.t.Fatal("No results are set for the PostgresMock.QueryRow")
		}
		return (*mm_results).r1
	}
	if mmQueryRow.funcQueryRow != nil {
		return mmQueryRow.funcQueryRow(ctx, query, args...)
	}
	mmQueryRow.t.Fatalf("Unexpected call to PostgresMock.QueryRow. %v %v %v", ctx, query, args)
	return
}

// QueryRowAfterCounter returns a count of finished PostgresMock.QueryRow invocations
func (mmQueryRow *PostgresMock) QueryRowAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.afterQueryRowCounter)
}

// QueryRowBeforeCounter returns a count of PostgresMock.QueryRow invocations
func (mmQueryRow *PostgresMock) QueryRowBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmQueryRow.beforeQueryRowCounter)
}

// Calls returns a list of arguments used in each call to PostgresMock.QueryRow.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmQueryRow *mPostgresMockQueryRow) Calls() []*PostgresMockQueryRowParams {
	mmQueryRow.mutex.RLock()

	argCopy := make([]*PostgresMockQueryRowParams, len(mmQueryRow.callArgs))
	copy(argCopy, mmQueryRow.callArgs)

	mmQueryRow.mutex.RUnlock()

	return argCopy
}

// MinimockQueryRowDone returns true if the count of the QueryRow invocations corresponds
// the number of defined expectations
func (m *PostgresMock) MinimockQueryRowDone() bool {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		return false
	}
	return true
}

// MinimockQueryRowInspect logs each unmet expectation
func (m *PostgresMock) MinimockQueryRowInspect() {
	for _, e := range m.QueryRowMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresMock.QueryRow with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.QueryRowMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		if m.QueryRowMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostgresMock.QueryRow")
		} else {
			m.t.Errorf("Expected call to PostgresMock.QueryRow with params: %#v", *m.QueryRowMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcQueryRow != nil && mm_atomic.LoadUint64(&m.afterQueryRowCounter) < 1 {
		m.t.Error("Expected call to PostgresMock.QueryRow")
	}
}

type mPostgresMockSelect struct {
	mock               *PostgresMock
	defaultExpectation *PostgresMockSelectExpectation
	expectations       []*PostgresMockSelectExpectation

	callArgs []*PostgresMockSelectParams
	mutex    sync.RWMutex
}

// PostgresMockSelectExpectation specifies expectation struct of the postgres.Select
type PostgresMockSelectExpectation struct {
	mock    *PostgresMock
	params  *PostgresMockSelectParams
	results *PostgresMockSelectResults
	Counter uint64
}

// PostgresMockSelectParams contains parameters of the postgres.Select
type PostgresMockSelectParams struct {
	ctx   context.Context
	dest  any
	query string
	args  []any
}

// PostgresMockSelectResults contains results of the postgres.Select
type PostgresMockSelectResults struct {
	err error
}

// Expect sets up expected params for postgres.Select
func (mmSelect *mPostgresMockSelect) Expect(ctx context.Context, dest any, query string, args ...any) *mPostgresMockSelect {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &PostgresMockSelectExpectation{}
	}

	mmSelect.defaultExpectation.params = &PostgresMockSelectParams{ctx, dest, query, args}
	for _, e := range mmSelect.expectations {
		if minimock.Equal(e.params, mmSelect.defaultExpectation.params) {
			mmSelect.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSelect.defaultExpectation.params)
		}
	}

	return mmSelect
}

// Inspect accepts an inspector function that has same arguments as the postgres.Select
func (mmSelect *mPostgresMockSelect) Inspect(f func(ctx context.Context, dest any, query string, args ...any)) *mPostgresMockSelect {
	if mmSelect.mock.inspectFuncSelect != nil {
		mmSelect.mock.t.Fatalf("Inspect function is already set for PostgresMock.Select")
	}

	mmSelect.mock.inspectFuncSelect = f

	return mmSelect
}

// Return sets up results that will be returned by postgres.Select
func (mmSelect *mPostgresMockSelect) Return(err error) *PostgresMock {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresMock.Select mock is already set by Set")
	}

	if mmSelect.defaultExpectation == nil {
		mmSelect.defaultExpectation = &PostgresMockSelectExpectation{mock: mmSelect.mock}
	}
	mmSelect.defaultExpectation.results = &PostgresMockSelectResults{err}
	return mmSelect.mock
}

// Set uses given function f to mock the postgres.Select method
func (mmSelect *mPostgresMockSelect) Set(f func(ctx context.Context, dest any, query string, args ...any) (err error)) *PostgresMock {
	if mmSelect.defaultExpectation != nil {
		mmSelect.mock.t.Fatalf("Default expectation is already set for the postgres.Select method")
	}

	if len(mmSelect.expectations) > 0 {
		mmSelect.mock.t.Fatalf("Some expectations are already set for the postgres.Select method")
	}

	mmSelect.mock.funcSelect = f
	return mmSelect.mock
}

// When sets expectation for the postgres.Select which will trigger the result defined by the following
// Then helper
func (mmSelect *mPostgresMockSelect) When(ctx context.Context, dest any, query string, args ...any) *PostgresMockSelectExpectation {
	if mmSelect.mock.funcSelect != nil {
		mmSelect.mock.t.Fatalf("PostgresMock.Select mock is already set by Set")
	}

	expectation := &PostgresMockSelectExpectation{
		mock:   mmSelect.mock,
		params: &PostgresMockSelectParams{ctx, dest, query, args},
	}
	mmSelect.expectations = append(mmSelect.expectations, expectation)
	return expectation
}

// Then sets up postgres.Select return parameters for the expectation previously defined by the When method
func (e *PostgresMockSelectExpectation) Then(err error) *PostgresMock {
	e.results = &PostgresMockSelectResults{err}
	return e.mock
}

// Select implements repo.postgres
func (mmSelect *PostgresMock) Select(ctx context.Context, dest any, query string, args ...any) (err error) {
	mm_atomic.AddUint64(&mmSelect.beforeSelectCounter, 1)
	defer mm_atomic.AddUint64(&mmSelect.afterSelectCounter, 1)

	if mmSelect.inspectFuncSelect != nil {
		mmSelect.inspectFuncSelect(ctx, dest, query, args...)
	}

	mm_params := PostgresMockSelectParams{ctx, dest, query, args}

	// Record call args
	mmSelect.SelectMock.mutex.Lock()
	mmSelect.SelectMock.callArgs = append(mmSelect.SelectMock.callArgs, &mm_params)
	mmSelect.SelectMock.mutex.Unlock()

	for _, e := range mmSelect.SelectMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSelect.SelectMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSelect.SelectMock.defaultExpectation.Counter, 1)
		mm_want := mmSelect.SelectMock.defaultExpectation.params
		mm_got := PostgresMockSelectParams{ctx, dest, query, args}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSelect.t.Errorf("PostgresMock.Select got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSelect.SelectMock.defaultExpectation.results
		if mm_results == nil {
			mmSelect.t.Fatal("No results are set for the PostgresMock.Select")
		}
		return (*mm_results).err
	}
	if mmSelect.funcSelect != nil {
		return mmSelect.funcSelect(ctx, dest, query, args...)
	}
	mmSelect.t.Fatalf("Unexpected call to PostgresMock.Select. %v %v %v %v", ctx, dest, query, args)
	return
}

// SelectAfterCounter returns a count of finished PostgresMock.Select invocations
func (mmSelect *PostgresMock) SelectAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelect.afterSelectCounter)
}

// SelectBeforeCounter returns a count of PostgresMock.Select invocations
func (mmSelect *PostgresMock) SelectBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSelect.beforeSelectCounter)
}

// Calls returns a list of arguments used in each call to PostgresMock.Select.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSelect *mPostgresMockSelect) Calls() []*PostgresMockSelectParams {
	mmSelect.mutex.RLock()

	argCopy := make([]*PostgresMockSelectParams, len(mmSelect.callArgs))
	copy(argCopy, mmSelect.callArgs)

	mmSelect.mutex.RUnlock()

	return argCopy
}

// MinimockSelectDone returns true if the count of the Select invocations corresponds
// the number of defined expectations
func (m *PostgresMock) MinimockSelectDone() bool {
	for _, e := range m.SelectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelect != nil && mm_atomic.LoadUint64(&m.afterSelectCounter) < 1 {
		return false
	}
	return true
}

// MinimockSelectInspect logs each unmet expectation
func (m *PostgresMock) MinimockSelectInspect() {
	for _, e := range m.SelectMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PostgresMock.Select with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SelectMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSelectCounter) < 1 {
		if m.SelectMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to PostgresMock.Select")
		} else {
			m.t.Errorf("Expected call to PostgresMock.Select with params: %#v", *m.SelectMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSelect != nil && mm_atomic.LoadUint64(&m.afterSelectCounter) < 1 {
		m.t.Error("Expected call to PostgresMock.Select")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PostgresMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockExecInspect()

			m.MinimockGetInspect()

			m.MinimockGetPoolInspect()

			m.MinimockQueryInspect()

			m.MinimockQueryRowInspect()

			m.MinimockSelectInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PostgresMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PostgresMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockExecDone() &&
		m.MinimockGetDone() &&
		m.MinimockGetPoolDone() &&
		m.MinimockQueryDone() &&
		m.MinimockQueryRowDone() &&
		m.MinimockSelectDone()
}

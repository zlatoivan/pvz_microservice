// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"gitlab.ozon.dev/zlatoivan4/homework/internal/model"
)

// RepoMock implements order.repo
type RepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(ctx context.Context, order model.Order) (u1 uuid.UUID, err error)
	inspectFuncCreateOrder   func(ctx context.Context, order model.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mRepoMockCreateOrder

	funcDeleteOrder          func(ctx context.Context, id uuid.UUID) (err error)
	inspectFuncDeleteOrder   func(ctx context.Context, id uuid.UUID)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mRepoMockDeleteOrder

	funcGetOrderByID          func(ctx context.Context, id uuid.UUID) (o1 model.Order, err error)
	inspectFuncGetOrderByID   func(ctx context.Context, id uuid.UUID)
	afterGetOrderByIDCounter  uint64
	beforeGetOrderByIDCounter uint64
	GetOrderByIDMock          mRepoMockGetOrderByID

	funcGiveOutOrder          func(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error)
	inspectFuncGiveOutOrder   func(ctx context.Context, clientID uuid.UUID, id uuid.UUID)
	afterGiveOutOrderCounter  uint64
	beforeGiveOutOrderCounter uint64
	GiveOutOrderMock          mRepoMockGiveOutOrder

	funcListClientOrders          func(ctx context.Context, id uuid.UUID) (oa1 []model.Order, err error)
	inspectFuncListClientOrders   func(ctx context.Context, id uuid.UUID)
	afterListClientOrdersCounter  uint64
	beforeListClientOrdersCounter uint64
	ListClientOrdersMock          mRepoMockListClientOrders

	funcListOrders          func(ctx context.Context) (oa1 []model.Order, err error)
	inspectFuncListOrders   func(ctx context.Context)
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mRepoMockListOrders

	funcListReturnedOrders          func(ctx context.Context) (oa1 []model.Order, err error)
	inspectFuncListReturnedOrders   func(ctx context.Context)
	afterListReturnedOrdersCounter  uint64
	beforeListReturnedOrdersCounter uint64
	ListReturnedOrdersMock          mRepoMockListReturnedOrders

	funcReturnOrder          func(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error)
	inspectFuncReturnOrder   func(ctx context.Context, clientID uuid.UUID, id uuid.UUID)
	afterReturnOrderCounter  uint64
	beforeReturnOrderCounter uint64
	ReturnOrderMock          mRepoMockReturnOrder

	funcUpdateOrder          func(ctx context.Context, updOrder model.Order) (err error)
	inspectFuncUpdateOrder   func(ctx context.Context, updOrder model.Order)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mRepoMockUpdateOrder
}

// NewRepoMock returns a mock for order.repo
func NewRepoMock(t minimock.Tester) *RepoMock {
	m := &RepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mRepoMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*RepoMockCreateOrderParams{}

	m.DeleteOrderMock = mRepoMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*RepoMockDeleteOrderParams{}

	m.GetOrderByIDMock = mRepoMockGetOrderByID{mock: m}
	m.GetOrderByIDMock.callArgs = []*RepoMockGetOrderByIDParams{}

	m.GiveOutOrderMock = mRepoMockGiveOutOrder{mock: m}
	m.GiveOutOrderMock.callArgs = []*RepoMockGiveOutOrderParams{}

	m.ListClientOrdersMock = mRepoMockListClientOrders{mock: m}
	m.ListClientOrdersMock.callArgs = []*RepoMockListClientOrdersParams{}

	m.ListOrdersMock = mRepoMockListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*RepoMockListOrdersParams{}

	m.ListReturnedOrdersMock = mRepoMockListReturnedOrders{mock: m}
	m.ListReturnedOrdersMock.callArgs = []*RepoMockListReturnedOrdersParams{}

	m.ReturnOrderMock = mRepoMockReturnOrder{mock: m}
	m.ReturnOrderMock.callArgs = []*RepoMockReturnOrderParams{}

	m.UpdateOrderMock = mRepoMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*RepoMockUpdateOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepoMockCreateOrder struct {
	mock               *RepoMock
	defaultExpectation *RepoMockCreateOrderExpectation
	expectations       []*RepoMockCreateOrderExpectation

	callArgs []*RepoMockCreateOrderParams
	mutex    sync.RWMutex
}

// RepoMockCreateOrderExpectation specifies expectation struct of the repo.CreateOrder
type RepoMockCreateOrderExpectation struct {
	mock    *RepoMock
	params  *RepoMockCreateOrderParams
	results *RepoMockCreateOrderResults
	Counter uint64
}

// RepoMockCreateOrderParams contains parameters of the repo.CreateOrder
type RepoMockCreateOrderParams struct {
	ctx   context.Context
	order model.Order
}

// RepoMockCreateOrderResults contains results of the repo.CreateOrder
type RepoMockCreateOrderResults struct {
	u1  uuid.UUID
	err error
}

// Expect sets up expected params for repo.CreateOrder
func (mmCreateOrder *mRepoMockCreateOrder) Expect(ctx context.Context, order model.Order) *mRepoMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &RepoMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &RepoMockCreateOrderParams{ctx, order}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the repo.CreateOrder
func (mmCreateOrder *mRepoMockCreateOrder) Inspect(f func(ctx context.Context, order model.Order)) *mRepoMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for RepoMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by repo.CreateOrder
func (mmCreateOrder *mRepoMockCreateOrder) Return(u1 uuid.UUID, err error) *RepoMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepoMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &RepoMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &RepoMockCreateOrderResults{u1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the repo.CreateOrder method
func (mmCreateOrder *mRepoMockCreateOrder) Set(f func(ctx context.Context, order model.Order) (u1 uuid.UUID, err error)) *RepoMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the repo.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the repo.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the repo.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mRepoMockCreateOrder) When(ctx context.Context, order model.Order) *RepoMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("RepoMock.CreateOrder mock is already set by Set")
	}

	expectation := &RepoMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &RepoMockCreateOrderParams{ctx, order},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up repo.CreateOrder return parameters for the expectation previously defined by the When method
func (e *RepoMockCreateOrderExpectation) Then(u1 uuid.UUID, err error) *RepoMock {
	e.results = &RepoMockCreateOrderResults{u1, err}
	return e.mock
}

// CreateOrder implements order.repo
func (mmCreateOrder *RepoMock) CreateOrder(ctx context.Context, order model.Order) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, order)
	}

	mm_params := RepoMockCreateOrderParams{ctx, order}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := RepoMockCreateOrderParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("RepoMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the RepoMock.CreateOrder")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, order)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to RepoMock.CreateOrder. %v %v", ctx, order)
	return
}

// CreateOrderAfterCounter returns a count of finished RepoMock.CreateOrder invocations
func (mmCreateOrder *RepoMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of RepoMock.CreateOrder invocations
func (mmCreateOrder *RepoMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mRepoMockCreateOrder) Calls() []*RepoMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*RepoMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *RepoMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to RepoMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to RepoMock.CreateOrder")
	}
}

type mRepoMockDeleteOrder struct {
	mock               *RepoMock
	defaultExpectation *RepoMockDeleteOrderExpectation
	expectations       []*RepoMockDeleteOrderExpectation

	callArgs []*RepoMockDeleteOrderParams
	mutex    sync.RWMutex
}

// RepoMockDeleteOrderExpectation specifies expectation struct of the repo.DeleteOrder
type RepoMockDeleteOrderExpectation struct {
	mock    *RepoMock
	params  *RepoMockDeleteOrderParams
	results *RepoMockDeleteOrderResults
	Counter uint64
}

// RepoMockDeleteOrderParams contains parameters of the repo.DeleteOrder
type RepoMockDeleteOrderParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepoMockDeleteOrderResults contains results of the repo.DeleteOrder
type RepoMockDeleteOrderResults struct {
	err error
}

// Expect sets up expected params for repo.DeleteOrder
func (mmDeleteOrder *mRepoMockDeleteOrder) Expect(ctx context.Context, id uuid.UUID) *mRepoMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("RepoMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &RepoMockDeleteOrderExpectation{}
	}

	mmDeleteOrder.defaultExpectation.params = &RepoMockDeleteOrderParams{ctx, id}
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the repo.DeleteOrder
func (mmDeleteOrder *mRepoMockDeleteOrder) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepoMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for RepoMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by repo.DeleteOrder
func (mmDeleteOrder *mRepoMockDeleteOrder) Return(err error) *RepoMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("RepoMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &RepoMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &RepoMockDeleteOrderResults{err}
	return mmDeleteOrder.mock
}

// Set uses given function f to mock the repo.DeleteOrder method
func (mmDeleteOrder *mRepoMockDeleteOrder) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *RepoMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the repo.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the repo.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	return mmDeleteOrder.mock
}

// When sets expectation for the repo.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mRepoMockDeleteOrder) When(ctx context.Context, id uuid.UUID) *RepoMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("RepoMock.DeleteOrder mock is already set by Set")
	}

	expectation := &RepoMockDeleteOrderExpectation{
		mock:   mmDeleteOrder.mock,
		params: &RepoMockDeleteOrderParams{ctx, id},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up repo.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *RepoMockDeleteOrderExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockDeleteOrderResults{err}
	return e.mock
}

// DeleteOrder implements order.repo
func (mmDeleteOrder *RepoMock) DeleteOrder(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, id)
	}

	mm_params := RepoMockDeleteOrderParams{ctx, id}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, &mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_got := RepoMockDeleteOrderParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("RepoMock.DeleteOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the RepoMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, id)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to RepoMock.DeleteOrder. %v %v", ctx, id)
	return
}

// DeleteOrderAfterCounter returns a count of finished RepoMock.DeleteOrder invocations
func (mmDeleteOrder *RepoMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of RepoMock.DeleteOrder invocations
func (mmDeleteOrder *RepoMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mRepoMockDeleteOrder) Calls() []*RepoMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*RepoMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockDeleteOrderDone() bool {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *RepoMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.DeleteOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.DeleteOrder")
		} else {
			m.t.Errorf("Expected call to RepoMock.DeleteOrder with params: %#v", *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		m.t.Error("Expected call to RepoMock.DeleteOrder")
	}
}

type mRepoMockGetOrderByID struct {
	mock               *RepoMock
	defaultExpectation *RepoMockGetOrderByIDExpectation
	expectations       []*RepoMockGetOrderByIDExpectation

	callArgs []*RepoMockGetOrderByIDParams
	mutex    sync.RWMutex
}

// RepoMockGetOrderByIDExpectation specifies expectation struct of the repo.GetOrderByID
type RepoMockGetOrderByIDExpectation struct {
	mock    *RepoMock
	params  *RepoMockGetOrderByIDParams
	results *RepoMockGetOrderByIDResults
	Counter uint64
}

// RepoMockGetOrderByIDParams contains parameters of the repo.GetOrderByID
type RepoMockGetOrderByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepoMockGetOrderByIDResults contains results of the repo.GetOrderByID
type RepoMockGetOrderByIDResults struct {
	o1  model.Order
	err error
}

// Expect sets up expected params for repo.GetOrderByID
func (mmGetOrderByID *mRepoMockGetOrderByID) Expect(ctx context.Context, id uuid.UUID) *mRepoMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("RepoMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &RepoMockGetOrderByIDExpectation{}
	}

	mmGetOrderByID.defaultExpectation.params = &RepoMockGetOrderByIDParams{ctx, id}
	for _, e := range mmGetOrderByID.expectations {
		if minimock.Equal(e.params, mmGetOrderByID.defaultExpectation.params) {
			mmGetOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderByID.defaultExpectation.params)
		}
	}

	return mmGetOrderByID
}

// Inspect accepts an inspector function that has same arguments as the repo.GetOrderByID
func (mmGetOrderByID *mRepoMockGetOrderByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepoMockGetOrderByID {
	if mmGetOrderByID.mock.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("Inspect function is already set for RepoMock.GetOrderByID")
	}

	mmGetOrderByID.mock.inspectFuncGetOrderByID = f

	return mmGetOrderByID
}

// Return sets up results that will be returned by repo.GetOrderByID
func (mmGetOrderByID *mRepoMockGetOrderByID) Return(o1 model.Order, err error) *RepoMock {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("RepoMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &RepoMockGetOrderByIDExpectation{mock: mmGetOrderByID.mock}
	}
	mmGetOrderByID.defaultExpectation.results = &RepoMockGetOrderByIDResults{o1, err}
	return mmGetOrderByID.mock
}

// Set uses given function f to mock the repo.GetOrderByID method
func (mmGetOrderByID *mRepoMockGetOrderByID) Set(f func(ctx context.Context, id uuid.UUID) (o1 model.Order, err error)) *RepoMock {
	if mmGetOrderByID.defaultExpectation != nil {
		mmGetOrderByID.mock.t.Fatalf("Default expectation is already set for the repo.GetOrderByID method")
	}

	if len(mmGetOrderByID.expectations) > 0 {
		mmGetOrderByID.mock.t.Fatalf("Some expectations are already set for the repo.GetOrderByID method")
	}

	mmGetOrderByID.mock.funcGetOrderByID = f
	return mmGetOrderByID.mock
}

// When sets expectation for the repo.GetOrderByID which will trigger the result defined by the following
// Then helper
func (mmGetOrderByID *mRepoMockGetOrderByID) When(ctx context.Context, id uuid.UUID) *RepoMockGetOrderByIDExpectation {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("RepoMock.GetOrderByID mock is already set by Set")
	}

	expectation := &RepoMockGetOrderByIDExpectation{
		mock:   mmGetOrderByID.mock,
		params: &RepoMockGetOrderByIDParams{ctx, id},
	}
	mmGetOrderByID.expectations = append(mmGetOrderByID.expectations, expectation)
	return expectation
}

// Then sets up repo.GetOrderByID return parameters for the expectation previously defined by the When method
func (e *RepoMockGetOrderByIDExpectation) Then(o1 model.Order, err error) *RepoMock {
	e.results = &RepoMockGetOrderByIDResults{o1, err}
	return e.mock
}

// GetOrderByID implements order.repo
func (mmGetOrderByID *RepoMock) GetOrderByID(ctx context.Context, id uuid.UUID) (o1 model.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrderByID.beforeGetOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderByID.afterGetOrderByIDCounter, 1)

	if mmGetOrderByID.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.inspectFuncGetOrderByID(ctx, id)
	}

	mm_params := RepoMockGetOrderByIDParams{ctx, id}

	// Record call args
	mmGetOrderByID.GetOrderByIDMock.mutex.Lock()
	mmGetOrderByID.GetOrderByIDMock.callArgs = append(mmGetOrderByID.GetOrderByIDMock.callArgs, &mm_params)
	mmGetOrderByID.GetOrderByIDMock.mutex.Unlock()

	for _, e := range mmGetOrderByID.GetOrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetOrderByID.GetOrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderByID.GetOrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.params
		mm_got := RepoMockGetOrderByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderByID.t.Errorf("RepoMock.GetOrderByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderByID.t.Fatal("No results are set for the RepoMock.GetOrderByID")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetOrderByID.funcGetOrderByID != nil {
		return mmGetOrderByID.funcGetOrderByID(ctx, id)
	}
	mmGetOrderByID.t.Fatalf("Unexpected call to RepoMock.GetOrderByID. %v %v", ctx, id)
	return
}

// GetOrderByIDAfterCounter returns a count of finished RepoMock.GetOrderByID invocations
func (mmGetOrderByID *RepoMock) GetOrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.afterGetOrderByIDCounter)
}

// GetOrderByIDBeforeCounter returns a count of RepoMock.GetOrderByID invocations
func (mmGetOrderByID *RepoMock) GetOrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.beforeGetOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.GetOrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderByID *mRepoMockGetOrderByID) Calls() []*RepoMockGetOrderByIDParams {
	mmGetOrderByID.mutex.RLock()

	argCopy := make([]*RepoMockGetOrderByIDParams, len(mmGetOrderByID.callArgs))
	copy(argCopy, mmGetOrderByID.callArgs)

	mmGetOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderByIDDone returns true if the count of the GetOrderByID invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockGetOrderByIDDone() bool {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderByIDInspect logs each unmet expectation
func (m *RepoMock) MinimockGetOrderByIDInspect() {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.GetOrderByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		if m.GetOrderByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.GetOrderByID")
		} else {
			m.t.Errorf("Expected call to RepoMock.GetOrderByID with params: %#v", *m.GetOrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		m.t.Error("Expected call to RepoMock.GetOrderByID")
	}
}

type mRepoMockGiveOutOrder struct {
	mock               *RepoMock
	defaultExpectation *RepoMockGiveOutOrderExpectation
	expectations       []*RepoMockGiveOutOrderExpectation

	callArgs []*RepoMockGiveOutOrderParams
	mutex    sync.RWMutex
}

// RepoMockGiveOutOrderExpectation specifies expectation struct of the repo.GiveOutOrder
type RepoMockGiveOutOrderExpectation struct {
	mock    *RepoMock
	params  *RepoMockGiveOutOrderParams
	results *RepoMockGiveOutOrderResults
	Counter uint64
}

// RepoMockGiveOutOrderParams contains parameters of the repo.GiveOutOrder
type RepoMockGiveOutOrderParams struct {
	ctx      context.Context
	clientID uuid.UUID
	id       uuid.UUID
}

// RepoMockGiveOutOrderResults contains results of the repo.GiveOutOrder
type RepoMockGiveOutOrderResults struct {
	err error
}

// Expect sets up expected params for repo.GiveOutOrder
func (mmGiveOutOrder *mRepoMockGiveOutOrder) Expect(ctx context.Context, clientID uuid.UUID, id uuid.UUID) *mRepoMockGiveOutOrder {
	if mmGiveOutOrder.mock.funcGiveOutOrder != nil {
		mmGiveOutOrder.mock.t.Fatalf("RepoMock.GiveOutOrder mock is already set by Set")
	}

	if mmGiveOutOrder.defaultExpectation == nil {
		mmGiveOutOrder.defaultExpectation = &RepoMockGiveOutOrderExpectation{}
	}

	mmGiveOutOrder.defaultExpectation.params = &RepoMockGiveOutOrderParams{ctx, clientID, id}
	for _, e := range mmGiveOutOrder.expectations {
		if minimock.Equal(e.params, mmGiveOutOrder.defaultExpectation.params) {
			mmGiveOutOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveOutOrder.defaultExpectation.params)
		}
	}

	return mmGiveOutOrder
}

// Inspect accepts an inspector function that has same arguments as the repo.GiveOutOrder
func (mmGiveOutOrder *mRepoMockGiveOutOrder) Inspect(f func(ctx context.Context, clientID uuid.UUID, id uuid.UUID)) *mRepoMockGiveOutOrder {
	if mmGiveOutOrder.mock.inspectFuncGiveOutOrder != nil {
		mmGiveOutOrder.mock.t.Fatalf("Inspect function is already set for RepoMock.GiveOutOrder")
	}

	mmGiveOutOrder.mock.inspectFuncGiveOutOrder = f

	return mmGiveOutOrder
}

// Return sets up results that will be returned by repo.GiveOutOrder
func (mmGiveOutOrder *mRepoMockGiveOutOrder) Return(err error) *RepoMock {
	if mmGiveOutOrder.mock.funcGiveOutOrder != nil {
		mmGiveOutOrder.mock.t.Fatalf("RepoMock.GiveOutOrder mock is already set by Set")
	}

	if mmGiveOutOrder.defaultExpectation == nil {
		mmGiveOutOrder.defaultExpectation = &RepoMockGiveOutOrderExpectation{mock: mmGiveOutOrder.mock}
	}
	mmGiveOutOrder.defaultExpectation.results = &RepoMockGiveOutOrderResults{err}
	return mmGiveOutOrder.mock
}

// Set uses given function f to mock the repo.GiveOutOrder method
func (mmGiveOutOrder *mRepoMockGiveOutOrder) Set(f func(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error)) *RepoMock {
	if mmGiveOutOrder.defaultExpectation != nil {
		mmGiveOutOrder.mock.t.Fatalf("Default expectation is already set for the repo.GiveOutOrder method")
	}

	if len(mmGiveOutOrder.expectations) > 0 {
		mmGiveOutOrder.mock.t.Fatalf("Some expectations are already set for the repo.GiveOutOrder method")
	}

	mmGiveOutOrder.mock.funcGiveOutOrder = f
	return mmGiveOutOrder.mock
}

// When sets expectation for the repo.GiveOutOrder which will trigger the result defined by the following
// Then helper
func (mmGiveOutOrder *mRepoMockGiveOutOrder) When(ctx context.Context, clientID uuid.UUID, id uuid.UUID) *RepoMockGiveOutOrderExpectation {
	if mmGiveOutOrder.mock.funcGiveOutOrder != nil {
		mmGiveOutOrder.mock.t.Fatalf("RepoMock.GiveOutOrder mock is already set by Set")
	}

	expectation := &RepoMockGiveOutOrderExpectation{
		mock:   mmGiveOutOrder.mock,
		params: &RepoMockGiveOutOrderParams{ctx, clientID, id},
	}
	mmGiveOutOrder.expectations = append(mmGiveOutOrder.expectations, expectation)
	return expectation
}

// Then sets up repo.GiveOutOrder return parameters for the expectation previously defined by the When method
func (e *RepoMockGiveOutOrderExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockGiveOutOrderResults{err}
	return e.mock
}

// GiveOutOrder implements order.repo
func (mmGiveOutOrder *RepoMock) GiveOutOrder(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmGiveOutOrder.beforeGiveOutOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveOutOrder.afterGiveOutOrderCounter, 1)

	if mmGiveOutOrder.inspectFuncGiveOutOrder != nil {
		mmGiveOutOrder.inspectFuncGiveOutOrder(ctx, clientID, id)
	}

	mm_params := RepoMockGiveOutOrderParams{ctx, clientID, id}

	// Record call args
	mmGiveOutOrder.GiveOutOrderMock.mutex.Lock()
	mmGiveOutOrder.GiveOutOrderMock.callArgs = append(mmGiveOutOrder.GiveOutOrderMock.callArgs, &mm_params)
	mmGiveOutOrder.GiveOutOrderMock.mutex.Unlock()

	for _, e := range mmGiveOutOrder.GiveOutOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGiveOutOrder.GiveOutOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveOutOrder.GiveOutOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveOutOrder.GiveOutOrderMock.defaultExpectation.params
		mm_got := RepoMockGiveOutOrderParams{ctx, clientID, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveOutOrder.t.Errorf("RepoMock.GiveOutOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveOutOrder.GiveOutOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveOutOrder.t.Fatal("No results are set for the RepoMock.GiveOutOrder")
		}
		return (*mm_results).err
	}
	if mmGiveOutOrder.funcGiveOutOrder != nil {
		return mmGiveOutOrder.funcGiveOutOrder(ctx, clientID, id)
	}
	mmGiveOutOrder.t.Fatalf("Unexpected call to RepoMock.GiveOutOrder. %v %v %v", ctx, clientID, id)
	return
}

// GiveOutOrderAfterCounter returns a count of finished RepoMock.GiveOutOrder invocations
func (mmGiveOutOrder *RepoMock) GiveOutOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOutOrder.afterGiveOutOrderCounter)
}

// GiveOutOrderBeforeCounter returns a count of RepoMock.GiveOutOrder invocations
func (mmGiveOutOrder *RepoMock) GiveOutOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOutOrder.beforeGiveOutOrderCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.GiveOutOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveOutOrder *mRepoMockGiveOutOrder) Calls() []*RepoMockGiveOutOrderParams {
	mmGiveOutOrder.mutex.RLock()

	argCopy := make([]*RepoMockGiveOutOrderParams, len(mmGiveOutOrder.callArgs))
	copy(argCopy, mmGiveOutOrder.callArgs)

	mmGiveOutOrder.mutex.RUnlock()

	return argCopy
}

// MinimockGiveOutOrderDone returns true if the count of the GiveOutOrder invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockGiveOutOrderDone() bool {
	for _, e := range m.GiveOutOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOutOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGiveOutOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOutOrder != nil && mm_atomic.LoadUint64(&m.afterGiveOutOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockGiveOutOrderInspect logs each unmet expectation
func (m *RepoMock) MinimockGiveOutOrderInspect() {
	for _, e := range m.GiveOutOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.GiveOutOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOutOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGiveOutOrderCounter) < 1 {
		if m.GiveOutOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.GiveOutOrder")
		} else {
			m.t.Errorf("Expected call to RepoMock.GiveOutOrder with params: %#v", *m.GiveOutOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOutOrder != nil && mm_atomic.LoadUint64(&m.afterGiveOutOrderCounter) < 1 {
		m.t.Error("Expected call to RepoMock.GiveOutOrder")
	}
}

type mRepoMockListClientOrders struct {
	mock               *RepoMock
	defaultExpectation *RepoMockListClientOrdersExpectation
	expectations       []*RepoMockListClientOrdersExpectation

	callArgs []*RepoMockListClientOrdersParams
	mutex    sync.RWMutex
}

// RepoMockListClientOrdersExpectation specifies expectation struct of the repo.ListClientOrders
type RepoMockListClientOrdersExpectation struct {
	mock    *RepoMock
	params  *RepoMockListClientOrdersParams
	results *RepoMockListClientOrdersResults
	Counter uint64
}

// RepoMockListClientOrdersParams contains parameters of the repo.ListClientOrders
type RepoMockListClientOrdersParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepoMockListClientOrdersResults contains results of the repo.ListClientOrders
type RepoMockListClientOrdersResults struct {
	oa1 []model.Order
	err error
}

// Expect sets up expected params for repo.ListClientOrders
func (mmListClientOrders *mRepoMockListClientOrders) Expect(ctx context.Context, id uuid.UUID) *mRepoMockListClientOrders {
	if mmListClientOrders.mock.funcListClientOrders != nil {
		mmListClientOrders.mock.t.Fatalf("RepoMock.ListClientOrders mock is already set by Set")
	}

	if mmListClientOrders.defaultExpectation == nil {
		mmListClientOrders.defaultExpectation = &RepoMockListClientOrdersExpectation{}
	}

	mmListClientOrders.defaultExpectation.params = &RepoMockListClientOrdersParams{ctx, id}
	for _, e := range mmListClientOrders.expectations {
		if minimock.Equal(e.params, mmListClientOrders.defaultExpectation.params) {
			mmListClientOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListClientOrders.defaultExpectation.params)
		}
	}

	return mmListClientOrders
}

// Inspect accepts an inspector function that has same arguments as the repo.ListClientOrders
func (mmListClientOrders *mRepoMockListClientOrders) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepoMockListClientOrders {
	if mmListClientOrders.mock.inspectFuncListClientOrders != nil {
		mmListClientOrders.mock.t.Fatalf("Inspect function is already set for RepoMock.ListClientOrders")
	}

	mmListClientOrders.mock.inspectFuncListClientOrders = f

	return mmListClientOrders
}

// Return sets up results that will be returned by repo.ListClientOrders
func (mmListClientOrders *mRepoMockListClientOrders) Return(oa1 []model.Order, err error) *RepoMock {
	if mmListClientOrders.mock.funcListClientOrders != nil {
		mmListClientOrders.mock.t.Fatalf("RepoMock.ListClientOrders mock is already set by Set")
	}

	if mmListClientOrders.defaultExpectation == nil {
		mmListClientOrders.defaultExpectation = &RepoMockListClientOrdersExpectation{mock: mmListClientOrders.mock}
	}
	mmListClientOrders.defaultExpectation.results = &RepoMockListClientOrdersResults{oa1, err}
	return mmListClientOrders.mock
}

// Set uses given function f to mock the repo.ListClientOrders method
func (mmListClientOrders *mRepoMockListClientOrders) Set(f func(ctx context.Context, id uuid.UUID) (oa1 []model.Order, err error)) *RepoMock {
	if mmListClientOrders.defaultExpectation != nil {
		mmListClientOrders.mock.t.Fatalf("Default expectation is already set for the repo.ListClientOrders method")
	}

	if len(mmListClientOrders.expectations) > 0 {
		mmListClientOrders.mock.t.Fatalf("Some expectations are already set for the repo.ListClientOrders method")
	}

	mmListClientOrders.mock.funcListClientOrders = f
	return mmListClientOrders.mock
}

// When sets expectation for the repo.ListClientOrders which will trigger the result defined by the following
// Then helper
func (mmListClientOrders *mRepoMockListClientOrders) When(ctx context.Context, id uuid.UUID) *RepoMockListClientOrdersExpectation {
	if mmListClientOrders.mock.funcListClientOrders != nil {
		mmListClientOrders.mock.t.Fatalf("RepoMock.ListClientOrders mock is already set by Set")
	}

	expectation := &RepoMockListClientOrdersExpectation{
		mock:   mmListClientOrders.mock,
		params: &RepoMockListClientOrdersParams{ctx, id},
	}
	mmListClientOrders.expectations = append(mmListClientOrders.expectations, expectation)
	return expectation
}

// Then sets up repo.ListClientOrders return parameters for the expectation previously defined by the When method
func (e *RepoMockListClientOrdersExpectation) Then(oa1 []model.Order, err error) *RepoMock {
	e.results = &RepoMockListClientOrdersResults{oa1, err}
	return e.mock
}

// ListClientOrders implements order.repo
func (mmListClientOrders *RepoMock) ListClientOrders(ctx context.Context, id uuid.UUID) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmListClientOrders.beforeListClientOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListClientOrders.afterListClientOrdersCounter, 1)

	if mmListClientOrders.inspectFuncListClientOrders != nil {
		mmListClientOrders.inspectFuncListClientOrders(ctx, id)
	}

	mm_params := RepoMockListClientOrdersParams{ctx, id}

	// Record call args
	mmListClientOrders.ListClientOrdersMock.mutex.Lock()
	mmListClientOrders.ListClientOrdersMock.callArgs = append(mmListClientOrders.ListClientOrdersMock.callArgs, &mm_params)
	mmListClientOrders.ListClientOrdersMock.mutex.Unlock()

	for _, e := range mmListClientOrders.ListClientOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListClientOrders.ListClientOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListClientOrders.ListClientOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListClientOrders.ListClientOrdersMock.defaultExpectation.params
		mm_got := RepoMockListClientOrdersParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListClientOrders.t.Errorf("RepoMock.ListClientOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListClientOrders.ListClientOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListClientOrders.t.Fatal("No results are set for the RepoMock.ListClientOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListClientOrders.funcListClientOrders != nil {
		return mmListClientOrders.funcListClientOrders(ctx, id)
	}
	mmListClientOrders.t.Fatalf("Unexpected call to RepoMock.ListClientOrders. %v %v", ctx, id)
	return
}

// ListClientOrdersAfterCounter returns a count of finished RepoMock.ListClientOrders invocations
func (mmListClientOrders *RepoMock) ListClientOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListClientOrders.afterListClientOrdersCounter)
}

// ListClientOrdersBeforeCounter returns a count of RepoMock.ListClientOrders invocations
func (mmListClientOrders *RepoMock) ListClientOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListClientOrders.beforeListClientOrdersCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.ListClientOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListClientOrders *mRepoMockListClientOrders) Calls() []*RepoMockListClientOrdersParams {
	mmListClientOrders.mutex.RLock()

	argCopy := make([]*RepoMockListClientOrdersParams, len(mmListClientOrders.callArgs))
	copy(argCopy, mmListClientOrders.callArgs)

	mmListClientOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListClientOrdersDone returns true if the count of the ListClientOrders invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockListClientOrdersDone() bool {
	for _, e := range m.ListClientOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListClientOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListClientOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListClientOrders != nil && mm_atomic.LoadUint64(&m.afterListClientOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockListClientOrdersInspect logs each unmet expectation
func (m *RepoMock) MinimockListClientOrdersInspect() {
	for _, e := range m.ListClientOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.ListClientOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListClientOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListClientOrdersCounter) < 1 {
		if m.ListClientOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.ListClientOrders")
		} else {
			m.t.Errorf("Expected call to RepoMock.ListClientOrders with params: %#v", *m.ListClientOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListClientOrders != nil && mm_atomic.LoadUint64(&m.afterListClientOrdersCounter) < 1 {
		m.t.Error("Expected call to RepoMock.ListClientOrders")
	}
}

type mRepoMockListOrders struct {
	mock               *RepoMock
	defaultExpectation *RepoMockListOrdersExpectation
	expectations       []*RepoMockListOrdersExpectation

	callArgs []*RepoMockListOrdersParams
	mutex    sync.RWMutex
}

// RepoMockListOrdersExpectation specifies expectation struct of the repo.ListOrders
type RepoMockListOrdersExpectation struct {
	mock    *RepoMock
	params  *RepoMockListOrdersParams
	results *RepoMockListOrdersResults
	Counter uint64
}

// RepoMockListOrdersParams contains parameters of the repo.ListOrders
type RepoMockListOrdersParams struct {
	ctx context.Context
}

// RepoMockListOrdersResults contains results of the repo.ListOrders
type RepoMockListOrdersResults struct {
	oa1 []model.Order
	err error
}

// Expect sets up expected params for repo.ListOrders
func (mmListOrders *mRepoMockListOrders) Expect(ctx context.Context) *mRepoMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("RepoMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &RepoMockListOrdersExpectation{}
	}

	mmListOrders.defaultExpectation.params = &RepoMockListOrdersParams{ctx}
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the repo.ListOrders
func (mmListOrders *mRepoMockListOrders) Inspect(f func(ctx context.Context)) *mRepoMockListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for RepoMock.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by repo.ListOrders
func (mmListOrders *mRepoMockListOrders) Return(oa1 []model.Order, err error) *RepoMock {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("RepoMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &RepoMockListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &RepoMockListOrdersResults{oa1, err}
	return mmListOrders.mock
}

// Set uses given function f to mock the repo.ListOrders method
func (mmListOrders *mRepoMockListOrders) Set(f func(ctx context.Context) (oa1 []model.Order, err error)) *RepoMock {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the repo.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the repo.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	return mmListOrders.mock
}

// When sets expectation for the repo.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mRepoMockListOrders) When(ctx context.Context) *RepoMockListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("RepoMock.ListOrders mock is already set by Set")
	}

	expectation := &RepoMockListOrdersExpectation{
		mock:   mmListOrders.mock,
		params: &RepoMockListOrdersParams{ctx},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up repo.ListOrders return parameters for the expectation previously defined by the When method
func (e *RepoMockListOrdersExpectation) Then(oa1 []model.Order, err error) *RepoMock {
	e.results = &RepoMockListOrdersResults{oa1, err}
	return e.mock
}

// ListOrders implements order.repo
func (mmListOrders *RepoMock) ListOrders(ctx context.Context) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx)
	}

	mm_params := RepoMockListOrdersParams{ctx}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_got := RepoMockListOrdersParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("RepoMock.ListOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrders.t.Fatal("No results are set for the RepoMock.ListOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx)
	}
	mmListOrders.t.Fatalf("Unexpected call to RepoMock.ListOrders. %v", ctx)
	return
}

// ListOrdersAfterCounter returns a count of finished RepoMock.ListOrders invocations
func (mmListOrders *RepoMock) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of RepoMock.ListOrders invocations
func (mmListOrders *RepoMock) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mRepoMockListOrders) Calls() []*RepoMockListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*RepoMockListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockListOrdersDone() bool {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *RepoMock) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.ListOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.ListOrders")
		} else {
			m.t.Errorf("Expected call to RepoMock.ListOrders with params: %#v", *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		m.t.Error("Expected call to RepoMock.ListOrders")
	}
}

type mRepoMockListReturnedOrders struct {
	mock               *RepoMock
	defaultExpectation *RepoMockListReturnedOrdersExpectation
	expectations       []*RepoMockListReturnedOrdersExpectation

	callArgs []*RepoMockListReturnedOrdersParams
	mutex    sync.RWMutex
}

// RepoMockListReturnedOrdersExpectation specifies expectation struct of the repo.ListReturnedOrders
type RepoMockListReturnedOrdersExpectation struct {
	mock    *RepoMock
	params  *RepoMockListReturnedOrdersParams
	results *RepoMockListReturnedOrdersResults
	Counter uint64
}

// RepoMockListReturnedOrdersParams contains parameters of the repo.ListReturnedOrders
type RepoMockListReturnedOrdersParams struct {
	ctx context.Context
}

// RepoMockListReturnedOrdersResults contains results of the repo.ListReturnedOrders
type RepoMockListReturnedOrdersResults struct {
	oa1 []model.Order
	err error
}

// Expect sets up expected params for repo.ListReturnedOrders
func (mmListReturnedOrders *mRepoMockListReturnedOrders) Expect(ctx context.Context) *mRepoMockListReturnedOrders {
	if mmListReturnedOrders.mock.funcListReturnedOrders != nil {
		mmListReturnedOrders.mock.t.Fatalf("RepoMock.ListReturnedOrders mock is already set by Set")
	}

	if mmListReturnedOrders.defaultExpectation == nil {
		mmListReturnedOrders.defaultExpectation = &RepoMockListReturnedOrdersExpectation{}
	}

	mmListReturnedOrders.defaultExpectation.params = &RepoMockListReturnedOrdersParams{ctx}
	for _, e := range mmListReturnedOrders.expectations {
		if minimock.Equal(e.params, mmListReturnedOrders.defaultExpectation.params) {
			mmListReturnedOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturnedOrders.defaultExpectation.params)
		}
	}

	return mmListReturnedOrders
}

// Inspect accepts an inspector function that has same arguments as the repo.ListReturnedOrders
func (mmListReturnedOrders *mRepoMockListReturnedOrders) Inspect(f func(ctx context.Context)) *mRepoMockListReturnedOrders {
	if mmListReturnedOrders.mock.inspectFuncListReturnedOrders != nil {
		mmListReturnedOrders.mock.t.Fatalf("Inspect function is already set for RepoMock.ListReturnedOrders")
	}

	mmListReturnedOrders.mock.inspectFuncListReturnedOrders = f

	return mmListReturnedOrders
}

// Return sets up results that will be returned by repo.ListReturnedOrders
func (mmListReturnedOrders *mRepoMockListReturnedOrders) Return(oa1 []model.Order, err error) *RepoMock {
	if mmListReturnedOrders.mock.funcListReturnedOrders != nil {
		mmListReturnedOrders.mock.t.Fatalf("RepoMock.ListReturnedOrders mock is already set by Set")
	}

	if mmListReturnedOrders.defaultExpectation == nil {
		mmListReturnedOrders.defaultExpectation = &RepoMockListReturnedOrdersExpectation{mock: mmListReturnedOrders.mock}
	}
	mmListReturnedOrders.defaultExpectation.results = &RepoMockListReturnedOrdersResults{oa1, err}
	return mmListReturnedOrders.mock
}

// Set uses given function f to mock the repo.ListReturnedOrders method
func (mmListReturnedOrders *mRepoMockListReturnedOrders) Set(f func(ctx context.Context) (oa1 []model.Order, err error)) *RepoMock {
	if mmListReturnedOrders.defaultExpectation != nil {
		mmListReturnedOrders.mock.t.Fatalf("Default expectation is already set for the repo.ListReturnedOrders method")
	}

	if len(mmListReturnedOrders.expectations) > 0 {
		mmListReturnedOrders.mock.t.Fatalf("Some expectations are already set for the repo.ListReturnedOrders method")
	}

	mmListReturnedOrders.mock.funcListReturnedOrders = f
	return mmListReturnedOrders.mock
}

// When sets expectation for the repo.ListReturnedOrders which will trigger the result defined by the following
// Then helper
func (mmListReturnedOrders *mRepoMockListReturnedOrders) When(ctx context.Context) *RepoMockListReturnedOrdersExpectation {
	if mmListReturnedOrders.mock.funcListReturnedOrders != nil {
		mmListReturnedOrders.mock.t.Fatalf("RepoMock.ListReturnedOrders mock is already set by Set")
	}

	expectation := &RepoMockListReturnedOrdersExpectation{
		mock:   mmListReturnedOrders.mock,
		params: &RepoMockListReturnedOrdersParams{ctx},
	}
	mmListReturnedOrders.expectations = append(mmListReturnedOrders.expectations, expectation)
	return expectation
}

// Then sets up repo.ListReturnedOrders return parameters for the expectation previously defined by the When method
func (e *RepoMockListReturnedOrdersExpectation) Then(oa1 []model.Order, err error) *RepoMock {
	e.results = &RepoMockListReturnedOrdersResults{oa1, err}
	return e.mock
}

// ListReturnedOrders implements order.repo
func (mmListReturnedOrders *RepoMock) ListReturnedOrders(ctx context.Context) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmListReturnedOrders.beforeListReturnedOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListReturnedOrders.afterListReturnedOrdersCounter, 1)

	if mmListReturnedOrders.inspectFuncListReturnedOrders != nil {
		mmListReturnedOrders.inspectFuncListReturnedOrders(ctx)
	}

	mm_params := RepoMockListReturnedOrdersParams{ctx}

	// Record call args
	mmListReturnedOrders.ListReturnedOrdersMock.mutex.Lock()
	mmListReturnedOrders.ListReturnedOrdersMock.callArgs = append(mmListReturnedOrders.ListReturnedOrdersMock.callArgs, &mm_params)
	mmListReturnedOrders.ListReturnedOrdersMock.mutex.Unlock()

	for _, e := range mmListReturnedOrders.ListReturnedOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListReturnedOrders.ListReturnedOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReturnedOrders.ListReturnedOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListReturnedOrders.ListReturnedOrdersMock.defaultExpectation.params
		mm_got := RepoMockListReturnedOrdersParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReturnedOrders.t.Errorf("RepoMock.ListReturnedOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReturnedOrders.ListReturnedOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListReturnedOrders.t.Fatal("No results are set for the RepoMock.ListReturnedOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListReturnedOrders.funcListReturnedOrders != nil {
		return mmListReturnedOrders.funcListReturnedOrders(ctx)
	}
	mmListReturnedOrders.t.Fatalf("Unexpected call to RepoMock.ListReturnedOrders. %v", ctx)
	return
}

// ListReturnedOrdersAfterCounter returns a count of finished RepoMock.ListReturnedOrders invocations
func (mmListReturnedOrders *RepoMock) ListReturnedOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturnedOrders.afterListReturnedOrdersCounter)
}

// ListReturnedOrdersBeforeCounter returns a count of RepoMock.ListReturnedOrders invocations
func (mmListReturnedOrders *RepoMock) ListReturnedOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturnedOrders.beforeListReturnedOrdersCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.ListReturnedOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturnedOrders *mRepoMockListReturnedOrders) Calls() []*RepoMockListReturnedOrdersParams {
	mmListReturnedOrders.mutex.RLock()

	argCopy := make([]*RepoMockListReturnedOrdersParams, len(mmListReturnedOrders.callArgs))
	copy(argCopy, mmListReturnedOrders.callArgs)

	mmListReturnedOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListReturnedOrdersDone returns true if the count of the ListReturnedOrders invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockListReturnedOrdersDone() bool {
	for _, e := range m.ListReturnedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnedOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListReturnedOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturnedOrders != nil && mm_atomic.LoadUint64(&m.afterListReturnedOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockListReturnedOrdersInspect logs each unmet expectation
func (m *RepoMock) MinimockListReturnedOrdersInspect() {
	for _, e := range m.ListReturnedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.ListReturnedOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnedOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListReturnedOrdersCounter) < 1 {
		if m.ListReturnedOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.ListReturnedOrders")
		} else {
			m.t.Errorf("Expected call to RepoMock.ListReturnedOrders with params: %#v", *m.ListReturnedOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturnedOrders != nil && mm_atomic.LoadUint64(&m.afterListReturnedOrdersCounter) < 1 {
		m.t.Error("Expected call to RepoMock.ListReturnedOrders")
	}
}

type mRepoMockReturnOrder struct {
	mock               *RepoMock
	defaultExpectation *RepoMockReturnOrderExpectation
	expectations       []*RepoMockReturnOrderExpectation

	callArgs []*RepoMockReturnOrderParams
	mutex    sync.RWMutex
}

// RepoMockReturnOrderExpectation specifies expectation struct of the repo.ReturnOrder
type RepoMockReturnOrderExpectation struct {
	mock    *RepoMock
	params  *RepoMockReturnOrderParams
	results *RepoMockReturnOrderResults
	Counter uint64
}

// RepoMockReturnOrderParams contains parameters of the repo.ReturnOrder
type RepoMockReturnOrderParams struct {
	ctx      context.Context
	clientID uuid.UUID
	id       uuid.UUID
}

// RepoMockReturnOrderResults contains results of the repo.ReturnOrder
type RepoMockReturnOrderResults struct {
	err error
}

// Expect sets up expected params for repo.ReturnOrder
func (mmReturnOrder *mRepoMockReturnOrder) Expect(ctx context.Context, clientID uuid.UUID, id uuid.UUID) *mRepoMockReturnOrder {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("RepoMock.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &RepoMockReturnOrderExpectation{}
	}

	mmReturnOrder.defaultExpectation.params = &RepoMockReturnOrderParams{ctx, clientID, id}
	for _, e := range mmReturnOrder.expectations {
		if minimock.Equal(e.params, mmReturnOrder.defaultExpectation.params) {
			mmReturnOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturnOrder.defaultExpectation.params)
		}
	}

	return mmReturnOrder
}

// Inspect accepts an inspector function that has same arguments as the repo.ReturnOrder
func (mmReturnOrder *mRepoMockReturnOrder) Inspect(f func(ctx context.Context, clientID uuid.UUID, id uuid.UUID)) *mRepoMockReturnOrder {
	if mmReturnOrder.mock.inspectFuncReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Inspect function is already set for RepoMock.ReturnOrder")
	}

	mmReturnOrder.mock.inspectFuncReturnOrder = f

	return mmReturnOrder
}

// Return sets up results that will be returned by repo.ReturnOrder
func (mmReturnOrder *mRepoMockReturnOrder) Return(err error) *RepoMock {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("RepoMock.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &RepoMockReturnOrderExpectation{mock: mmReturnOrder.mock}
	}
	mmReturnOrder.defaultExpectation.results = &RepoMockReturnOrderResults{err}
	return mmReturnOrder.mock
}

// Set uses given function f to mock the repo.ReturnOrder method
func (mmReturnOrder *mRepoMockReturnOrder) Set(f func(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error)) *RepoMock {
	if mmReturnOrder.defaultExpectation != nil {
		mmReturnOrder.mock.t.Fatalf("Default expectation is already set for the repo.ReturnOrder method")
	}

	if len(mmReturnOrder.expectations) > 0 {
		mmReturnOrder.mock.t.Fatalf("Some expectations are already set for the repo.ReturnOrder method")
	}

	mmReturnOrder.mock.funcReturnOrder = f
	return mmReturnOrder.mock
}

// When sets expectation for the repo.ReturnOrder which will trigger the result defined by the following
// Then helper
func (mmReturnOrder *mRepoMockReturnOrder) When(ctx context.Context, clientID uuid.UUID, id uuid.UUID) *RepoMockReturnOrderExpectation {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("RepoMock.ReturnOrder mock is already set by Set")
	}

	expectation := &RepoMockReturnOrderExpectation{
		mock:   mmReturnOrder.mock,
		params: &RepoMockReturnOrderParams{ctx, clientID, id},
	}
	mmReturnOrder.expectations = append(mmReturnOrder.expectations, expectation)
	return expectation
}

// Then sets up repo.ReturnOrder return parameters for the expectation previously defined by the When method
func (e *RepoMockReturnOrderExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockReturnOrderResults{err}
	return e.mock
}

// ReturnOrder implements order.repo
func (mmReturnOrder *RepoMock) ReturnOrder(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmReturnOrder.beforeReturnOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmReturnOrder.afterReturnOrderCounter, 1)

	if mmReturnOrder.inspectFuncReturnOrder != nil {
		mmReturnOrder.inspectFuncReturnOrder(ctx, clientID, id)
	}

	mm_params := RepoMockReturnOrderParams{ctx, clientID, id}

	// Record call args
	mmReturnOrder.ReturnOrderMock.mutex.Lock()
	mmReturnOrder.ReturnOrderMock.callArgs = append(mmReturnOrder.ReturnOrderMock.callArgs, &mm_params)
	mmReturnOrder.ReturnOrderMock.mutex.Unlock()

	for _, e := range mmReturnOrder.ReturnOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReturnOrder.ReturnOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturnOrder.ReturnOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmReturnOrder.ReturnOrderMock.defaultExpectation.params
		mm_got := RepoMockReturnOrderParams{ctx, clientID, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturnOrder.t.Errorf("RepoMock.ReturnOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturnOrder.ReturnOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmReturnOrder.t.Fatal("No results are set for the RepoMock.ReturnOrder")
		}
		return (*mm_results).err
	}
	if mmReturnOrder.funcReturnOrder != nil {
		return mmReturnOrder.funcReturnOrder(ctx, clientID, id)
	}
	mmReturnOrder.t.Fatalf("Unexpected call to RepoMock.ReturnOrder. %v %v %v", ctx, clientID, id)
	return
}

// ReturnOrderAfterCounter returns a count of finished RepoMock.ReturnOrder invocations
func (mmReturnOrder *RepoMock) ReturnOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrder.afterReturnOrderCounter)
}

// ReturnOrderBeforeCounter returns a count of RepoMock.ReturnOrder invocations
func (mmReturnOrder *RepoMock) ReturnOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrder.beforeReturnOrderCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.ReturnOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturnOrder *mRepoMockReturnOrder) Calls() []*RepoMockReturnOrderParams {
	mmReturnOrder.mutex.RLock()

	argCopy := make([]*RepoMockReturnOrderParams, len(mmReturnOrder.callArgs))
	copy(argCopy, mmReturnOrder.callArgs)

	mmReturnOrder.mutex.RUnlock()

	return argCopy
}

// MinimockReturnOrderDone returns true if the count of the ReturnOrder invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockReturnOrderDone() bool {
	for _, e := range m.ReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReturnOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnOrder != nil && mm_atomic.LoadUint64(&m.afterReturnOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockReturnOrderInspect logs each unmet expectation
func (m *RepoMock) MinimockReturnOrderInspect() {
	for _, e := range m.ReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.ReturnOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReturnOrderCounter) < 1 {
		if m.ReturnOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.ReturnOrder")
		} else {
			m.t.Errorf("Expected call to RepoMock.ReturnOrder with params: %#v", *m.ReturnOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnOrder != nil && mm_atomic.LoadUint64(&m.afterReturnOrderCounter) < 1 {
		m.t.Error("Expected call to RepoMock.ReturnOrder")
	}
}

type mRepoMockUpdateOrder struct {
	mock               *RepoMock
	defaultExpectation *RepoMockUpdateOrderExpectation
	expectations       []*RepoMockUpdateOrderExpectation

	callArgs []*RepoMockUpdateOrderParams
	mutex    sync.RWMutex
}

// RepoMockUpdateOrderExpectation specifies expectation struct of the repo.UpdateOrder
type RepoMockUpdateOrderExpectation struct {
	mock    *RepoMock
	params  *RepoMockUpdateOrderParams
	results *RepoMockUpdateOrderResults
	Counter uint64
}

// RepoMockUpdateOrderParams contains parameters of the repo.UpdateOrder
type RepoMockUpdateOrderParams struct {
	ctx      context.Context
	updOrder model.Order
}

// RepoMockUpdateOrderResults contains results of the repo.UpdateOrder
type RepoMockUpdateOrderResults struct {
	err error
}

// Expect sets up expected params for repo.UpdateOrder
func (mmUpdateOrder *mRepoMockUpdateOrder) Expect(ctx context.Context, updOrder model.Order) *mRepoMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepoMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &RepoMockUpdateOrderExpectation{}
	}

	mmUpdateOrder.defaultExpectation.params = &RepoMockUpdateOrderParams{ctx, updOrder}
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the repo.UpdateOrder
func (mmUpdateOrder *mRepoMockUpdateOrder) Inspect(f func(ctx context.Context, updOrder model.Order)) *mRepoMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for RepoMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by repo.UpdateOrder
func (mmUpdateOrder *mRepoMockUpdateOrder) Return(err error) *RepoMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepoMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &RepoMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &RepoMockUpdateOrderResults{err}
	return mmUpdateOrder.mock
}

// Set uses given function f to mock the repo.UpdateOrder method
func (mmUpdateOrder *mRepoMockUpdateOrder) Set(f func(ctx context.Context, updOrder model.Order) (err error)) *RepoMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the repo.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the repo.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	return mmUpdateOrder.mock
}

// When sets expectation for the repo.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mRepoMockUpdateOrder) When(ctx context.Context, updOrder model.Order) *RepoMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("RepoMock.UpdateOrder mock is already set by Set")
	}

	expectation := &RepoMockUpdateOrderExpectation{
		mock:   mmUpdateOrder.mock,
		params: &RepoMockUpdateOrderParams{ctx, updOrder},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up repo.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *RepoMockUpdateOrderExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockUpdateOrderResults{err}
	return e.mock
}

// UpdateOrder implements order.repo
func (mmUpdateOrder *RepoMock) UpdateOrder(ctx context.Context, updOrder model.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, updOrder)
	}

	mm_params := RepoMockUpdateOrderParams{ctx, updOrder}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, &mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_got := RepoMockUpdateOrderParams{ctx, updOrder}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("RepoMock.UpdateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the RepoMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, updOrder)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to RepoMock.UpdateOrder. %v %v", ctx, updOrder)
	return
}

// UpdateOrderAfterCounter returns a count of finished RepoMock.UpdateOrder invocations
func (mmUpdateOrder *RepoMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of RepoMock.UpdateOrder invocations
func (mmUpdateOrder *RepoMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mRepoMockUpdateOrder) Calls() []*RepoMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*RepoMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockUpdateOrderDone() bool {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *RepoMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.UpdateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.UpdateOrder")
		} else {
			m.t.Errorf("Expected call to RepoMock.UpdateOrder with params: %#v", *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		m.t.Error("Expected call to RepoMock.UpdateOrder")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockDeleteOrderInspect()

			m.MinimockGetOrderByIDInspect()

			m.MinimockGiveOutOrderInspect()

			m.MinimockListClientOrdersInspect()

			m.MinimockListOrdersInspect()

			m.MinimockListReturnedOrdersInspect()

			m.MinimockReturnOrderInspect()

			m.MinimockUpdateOrderInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetOrderByIDDone() &&
		m.MinimockGiveOutOrderDone() &&
		m.MinimockListClientOrdersDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockListReturnedOrdersDone() &&
		m.MinimockReturnOrderDone() &&
		m.MinimockUpdateOrderDone()
}

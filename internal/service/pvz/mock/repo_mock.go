// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"gitlab.ozon.dev/zlatoivan4/homework/internal/model"
)

// RepoMock implements pvz.repo
type RepoMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreatePVZ          func(ctx context.Context, pvz model.PVZ) (u1 uuid.UUID, err error)
	inspectFuncCreatePVZ   func(ctx context.Context, pvz model.PVZ)
	afterCreatePVZCounter  uint64
	beforeCreatePVZCounter uint64
	CreatePVZMock          mRepoMockCreatePVZ

	funcDeletePVZ          func(ctx context.Context, id uuid.UUID) (err error)
	inspectFuncDeletePVZ   func(ctx context.Context, id uuid.UUID)
	afterDeletePVZCounter  uint64
	beforeDeletePVZCounter uint64
	DeletePVZMock          mRepoMockDeletePVZ

	funcGetPVZByID          func(ctx context.Context, id uuid.UUID) (p1 model.PVZ, err error)
	inspectFuncGetPVZByID   func(ctx context.Context, id uuid.UUID)
	afterGetPVZByIDCounter  uint64
	beforeGetPVZByIDCounter uint64
	GetPVZByIDMock          mRepoMockGetPVZByID

	funcListPVZs          func(ctx context.Context) (pa1 []model.PVZ, err error)
	inspectFuncListPVZs   func(ctx context.Context)
	afterListPVZsCounter  uint64
	beforeListPVZsCounter uint64
	ListPVZsMock          mRepoMockListPVZs

	funcUpdatePVZ          func(ctx context.Context, updPVZ model.PVZ) (err error)
	inspectFuncUpdatePVZ   func(ctx context.Context, updPVZ model.PVZ)
	afterUpdatePVZCounter  uint64
	beforeUpdatePVZCounter uint64
	UpdatePVZMock          mRepoMockUpdatePVZ
}

// NewRepoMock returns a mock for pvz.repo
func NewRepoMock(t minimock.Tester) *RepoMock {
	m := &RepoMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreatePVZMock = mRepoMockCreatePVZ{mock: m}
	m.CreatePVZMock.callArgs = []*RepoMockCreatePVZParams{}

	m.DeletePVZMock = mRepoMockDeletePVZ{mock: m}
	m.DeletePVZMock.callArgs = []*RepoMockDeletePVZParams{}

	m.GetPVZByIDMock = mRepoMockGetPVZByID{mock: m}
	m.GetPVZByIDMock.callArgs = []*RepoMockGetPVZByIDParams{}

	m.ListPVZsMock = mRepoMockListPVZs{mock: m}
	m.ListPVZsMock.callArgs = []*RepoMockListPVZsParams{}

	m.UpdatePVZMock = mRepoMockUpdatePVZ{mock: m}
	m.UpdatePVZMock.callArgs = []*RepoMockUpdatePVZParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepoMockCreatePVZ struct {
	mock               *RepoMock
	defaultExpectation *RepoMockCreatePVZExpectation
	expectations       []*RepoMockCreatePVZExpectation

	callArgs []*RepoMockCreatePVZParams
	mutex    sync.RWMutex
}

// RepoMockCreatePVZExpectation specifies expectation struct of the repo.CreatePVZ
type RepoMockCreatePVZExpectation struct {
	mock    *RepoMock
	params  *RepoMockCreatePVZParams
	results *RepoMockCreatePVZResults
	Counter uint64
}

// RepoMockCreatePVZParams contains parameters of the repo.CreatePVZ
type RepoMockCreatePVZParams struct {
	ctx context.Context
	pvz model.PVZ
}

// RepoMockCreatePVZResults contains results of the repo.CreatePVZ
type RepoMockCreatePVZResults struct {
	u1  uuid.UUID
	err error
}

// Expect sets up expected params for repo.CreatePVZ
func (mmCreatePVZ *mRepoMockCreatePVZ) Expect(ctx context.Context, pvz model.PVZ) *mRepoMockCreatePVZ {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("RepoMock.CreatePVZ mock is already set by Set")
	}

	if mmCreatePVZ.defaultExpectation == nil {
		mmCreatePVZ.defaultExpectation = &RepoMockCreatePVZExpectation{}
	}

	mmCreatePVZ.defaultExpectation.params = &RepoMockCreatePVZParams{ctx, pvz}
	for _, e := range mmCreatePVZ.expectations {
		if minimock.Equal(e.params, mmCreatePVZ.defaultExpectation.params) {
			mmCreatePVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreatePVZ.defaultExpectation.params)
		}
	}

	return mmCreatePVZ
}

// Inspect accepts an inspector function that has same arguments as the repo.CreatePVZ
func (mmCreatePVZ *mRepoMockCreatePVZ) Inspect(f func(ctx context.Context, pvz model.PVZ)) *mRepoMockCreatePVZ {
	if mmCreatePVZ.mock.inspectFuncCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("Inspect function is already set for RepoMock.CreatePVZ")
	}

	mmCreatePVZ.mock.inspectFuncCreatePVZ = f

	return mmCreatePVZ
}

// Return sets up results that will be returned by repo.CreatePVZ
func (mmCreatePVZ *mRepoMockCreatePVZ) Return(u1 uuid.UUID, err error) *RepoMock {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("RepoMock.CreatePVZ mock is already set by Set")
	}

	if mmCreatePVZ.defaultExpectation == nil {
		mmCreatePVZ.defaultExpectation = &RepoMockCreatePVZExpectation{mock: mmCreatePVZ.mock}
	}
	mmCreatePVZ.defaultExpectation.results = &RepoMockCreatePVZResults{u1, err}
	return mmCreatePVZ.mock
}

// Set uses given function f to mock the repo.CreatePVZ method
func (mmCreatePVZ *mRepoMockCreatePVZ) Set(f func(ctx context.Context, pvz model.PVZ) (u1 uuid.UUID, err error)) *RepoMock {
	if mmCreatePVZ.defaultExpectation != nil {
		mmCreatePVZ.mock.t.Fatalf("Default expectation is already set for the repo.CreatePVZ method")
	}

	if len(mmCreatePVZ.expectations) > 0 {
		mmCreatePVZ.mock.t.Fatalf("Some expectations are already set for the repo.CreatePVZ method")
	}

	mmCreatePVZ.mock.funcCreatePVZ = f
	return mmCreatePVZ.mock
}

// When sets expectation for the repo.CreatePVZ which will trigger the result defined by the following
// Then helper
func (mmCreatePVZ *mRepoMockCreatePVZ) When(ctx context.Context, pvz model.PVZ) *RepoMockCreatePVZExpectation {
	if mmCreatePVZ.mock.funcCreatePVZ != nil {
		mmCreatePVZ.mock.t.Fatalf("RepoMock.CreatePVZ mock is already set by Set")
	}

	expectation := &RepoMockCreatePVZExpectation{
		mock:   mmCreatePVZ.mock,
		params: &RepoMockCreatePVZParams{ctx, pvz},
	}
	mmCreatePVZ.expectations = append(mmCreatePVZ.expectations, expectation)
	return expectation
}

// Then sets up repo.CreatePVZ return parameters for the expectation previously defined by the When method
func (e *RepoMockCreatePVZExpectation) Then(u1 uuid.UUID, err error) *RepoMock {
	e.results = &RepoMockCreatePVZResults{u1, err}
	return e.mock
}

// CreatePVZ implements pvz.repo
func (mmCreatePVZ *RepoMock) CreatePVZ(ctx context.Context, pvz model.PVZ) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreatePVZ.beforeCreatePVZCounter, 1)
	defer mm_atomic.AddUint64(&mmCreatePVZ.afterCreatePVZCounter, 1)

	if mmCreatePVZ.inspectFuncCreatePVZ != nil {
		mmCreatePVZ.inspectFuncCreatePVZ(ctx, pvz)
	}

	mm_params := RepoMockCreatePVZParams{ctx, pvz}

	// Record call args
	mmCreatePVZ.CreatePVZMock.mutex.Lock()
	mmCreatePVZ.CreatePVZMock.callArgs = append(mmCreatePVZ.CreatePVZMock.callArgs, &mm_params)
	mmCreatePVZ.CreatePVZMock.mutex.Unlock()

	for _, e := range mmCreatePVZ.CreatePVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreatePVZ.CreatePVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreatePVZ.CreatePVZMock.defaultExpectation.Counter, 1)
		mm_want := mmCreatePVZ.CreatePVZMock.defaultExpectation.params
		mm_got := RepoMockCreatePVZParams{ctx, pvz}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreatePVZ.t.Errorf("RepoMock.CreatePVZ got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreatePVZ.CreatePVZMock.defaultExpectation.results
		if mm_results == nil {
			mmCreatePVZ.t.Fatal("No results are set for the RepoMock.CreatePVZ")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreatePVZ.funcCreatePVZ != nil {
		return mmCreatePVZ.funcCreatePVZ(ctx, pvz)
	}
	mmCreatePVZ.t.Fatalf("Unexpected call to RepoMock.CreatePVZ. %v %v", ctx, pvz)
	return
}

// CreatePVZAfterCounter returns a count of finished RepoMock.CreatePVZ invocations
func (mmCreatePVZ *RepoMock) CreatePVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePVZ.afterCreatePVZCounter)
}

// CreatePVZBeforeCounter returns a count of RepoMock.CreatePVZ invocations
func (mmCreatePVZ *RepoMock) CreatePVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreatePVZ.beforeCreatePVZCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.CreatePVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreatePVZ *mRepoMockCreatePVZ) Calls() []*RepoMockCreatePVZParams {
	mmCreatePVZ.mutex.RLock()

	argCopy := make([]*RepoMockCreatePVZParams, len(mmCreatePVZ.callArgs))
	copy(argCopy, mmCreatePVZ.callArgs)

	mmCreatePVZ.mutex.RUnlock()

	return argCopy
}

// MinimockCreatePVZDone returns true if the count of the CreatePVZ invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockCreatePVZDone() bool {
	for _, e := range m.CreatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreatePVZCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePVZ != nil && mm_atomic.LoadUint64(&m.afterCreatePVZCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreatePVZInspect logs each unmet expectation
func (m *RepoMock) MinimockCreatePVZInspect() {
	for _, e := range m.CreatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.CreatePVZ with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreatePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreatePVZCounter) < 1 {
		if m.CreatePVZMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.CreatePVZ")
		} else {
			m.t.Errorf("Expected call to RepoMock.CreatePVZ with params: %#v", *m.CreatePVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreatePVZ != nil && mm_atomic.LoadUint64(&m.afterCreatePVZCounter) < 1 {
		m.t.Error("Expected call to RepoMock.CreatePVZ")
	}
}

type mRepoMockDeletePVZ struct {
	mock               *RepoMock
	defaultExpectation *RepoMockDeletePVZExpectation
	expectations       []*RepoMockDeletePVZExpectation

	callArgs []*RepoMockDeletePVZParams
	mutex    sync.RWMutex
}

// RepoMockDeletePVZExpectation specifies expectation struct of the repo.DeletePVZ
type RepoMockDeletePVZExpectation struct {
	mock    *RepoMock
	params  *RepoMockDeletePVZParams
	results *RepoMockDeletePVZResults
	Counter uint64
}

// RepoMockDeletePVZParams contains parameters of the repo.DeletePVZ
type RepoMockDeletePVZParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepoMockDeletePVZResults contains results of the repo.DeletePVZ
type RepoMockDeletePVZResults struct {
	err error
}

// Expect sets up expected params for repo.DeletePVZ
func (mmDeletePVZ *mRepoMockDeletePVZ) Expect(ctx context.Context, id uuid.UUID) *mRepoMockDeletePVZ {
	if mmDeletePVZ.mock.funcDeletePVZ != nil {
		mmDeletePVZ.mock.t.Fatalf("RepoMock.DeletePVZ mock is already set by Set")
	}

	if mmDeletePVZ.defaultExpectation == nil {
		mmDeletePVZ.defaultExpectation = &RepoMockDeletePVZExpectation{}
	}

	mmDeletePVZ.defaultExpectation.params = &RepoMockDeletePVZParams{ctx, id}
	for _, e := range mmDeletePVZ.expectations {
		if minimock.Equal(e.params, mmDeletePVZ.defaultExpectation.params) {
			mmDeletePVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeletePVZ.defaultExpectation.params)
		}
	}

	return mmDeletePVZ
}

// Inspect accepts an inspector function that has same arguments as the repo.DeletePVZ
func (mmDeletePVZ *mRepoMockDeletePVZ) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepoMockDeletePVZ {
	if mmDeletePVZ.mock.inspectFuncDeletePVZ != nil {
		mmDeletePVZ.mock.t.Fatalf("Inspect function is already set for RepoMock.DeletePVZ")
	}

	mmDeletePVZ.mock.inspectFuncDeletePVZ = f

	return mmDeletePVZ
}

// Return sets up results that will be returned by repo.DeletePVZ
func (mmDeletePVZ *mRepoMockDeletePVZ) Return(err error) *RepoMock {
	if mmDeletePVZ.mock.funcDeletePVZ != nil {
		mmDeletePVZ.mock.t.Fatalf("RepoMock.DeletePVZ mock is already set by Set")
	}

	if mmDeletePVZ.defaultExpectation == nil {
		mmDeletePVZ.defaultExpectation = &RepoMockDeletePVZExpectation{mock: mmDeletePVZ.mock}
	}
	mmDeletePVZ.defaultExpectation.results = &RepoMockDeletePVZResults{err}
	return mmDeletePVZ.mock
}

// Set uses given function f to mock the repo.DeletePVZ method
func (mmDeletePVZ *mRepoMockDeletePVZ) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *RepoMock {
	if mmDeletePVZ.defaultExpectation != nil {
		mmDeletePVZ.mock.t.Fatalf("Default expectation is already set for the repo.DeletePVZ method")
	}

	if len(mmDeletePVZ.expectations) > 0 {
		mmDeletePVZ.mock.t.Fatalf("Some expectations are already set for the repo.DeletePVZ method")
	}

	mmDeletePVZ.mock.funcDeletePVZ = f
	return mmDeletePVZ.mock
}

// When sets expectation for the repo.DeletePVZ which will trigger the result defined by the following
// Then helper
func (mmDeletePVZ *mRepoMockDeletePVZ) When(ctx context.Context, id uuid.UUID) *RepoMockDeletePVZExpectation {
	if mmDeletePVZ.mock.funcDeletePVZ != nil {
		mmDeletePVZ.mock.t.Fatalf("RepoMock.DeletePVZ mock is already set by Set")
	}

	expectation := &RepoMockDeletePVZExpectation{
		mock:   mmDeletePVZ.mock,
		params: &RepoMockDeletePVZParams{ctx, id},
	}
	mmDeletePVZ.expectations = append(mmDeletePVZ.expectations, expectation)
	return expectation
}

// Then sets up repo.DeletePVZ return parameters for the expectation previously defined by the When method
func (e *RepoMockDeletePVZExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockDeletePVZResults{err}
	return e.mock
}

// DeletePVZ implements pvz.repo
func (mmDeletePVZ *RepoMock) DeletePVZ(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeletePVZ.beforeDeletePVZCounter, 1)
	defer mm_atomic.AddUint64(&mmDeletePVZ.afterDeletePVZCounter, 1)

	if mmDeletePVZ.inspectFuncDeletePVZ != nil {
		mmDeletePVZ.inspectFuncDeletePVZ(ctx, id)
	}

	mm_params := RepoMockDeletePVZParams{ctx, id}

	// Record call args
	mmDeletePVZ.DeletePVZMock.mutex.Lock()
	mmDeletePVZ.DeletePVZMock.callArgs = append(mmDeletePVZ.DeletePVZMock.callArgs, &mm_params)
	mmDeletePVZ.DeletePVZMock.mutex.Unlock()

	for _, e := range mmDeletePVZ.DeletePVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeletePVZ.DeletePVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeletePVZ.DeletePVZMock.defaultExpectation.Counter, 1)
		mm_want := mmDeletePVZ.DeletePVZMock.defaultExpectation.params
		mm_got := RepoMockDeletePVZParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeletePVZ.t.Errorf("RepoMock.DeletePVZ got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeletePVZ.DeletePVZMock.defaultExpectation.results
		if mm_results == nil {
			mmDeletePVZ.t.Fatal("No results are set for the RepoMock.DeletePVZ")
		}
		return (*mm_results).err
	}
	if mmDeletePVZ.funcDeletePVZ != nil {
		return mmDeletePVZ.funcDeletePVZ(ctx, id)
	}
	mmDeletePVZ.t.Fatalf("Unexpected call to RepoMock.DeletePVZ. %v %v", ctx, id)
	return
}

// DeletePVZAfterCounter returns a count of finished RepoMock.DeletePVZ invocations
func (mmDeletePVZ *RepoMock) DeletePVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePVZ.afterDeletePVZCounter)
}

// DeletePVZBeforeCounter returns a count of RepoMock.DeletePVZ invocations
func (mmDeletePVZ *RepoMock) DeletePVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeletePVZ.beforeDeletePVZCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.DeletePVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeletePVZ *mRepoMockDeletePVZ) Calls() []*RepoMockDeletePVZParams {
	mmDeletePVZ.mutex.RLock()

	argCopy := make([]*RepoMockDeletePVZParams, len(mmDeletePVZ.callArgs))
	copy(argCopy, mmDeletePVZ.callArgs)

	mmDeletePVZ.mutex.RUnlock()

	return argCopy
}

// MinimockDeletePVZDone returns true if the count of the DeletePVZ invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockDeletePVZDone() bool {
	for _, e := range m.DeletePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeletePVZCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePVZ != nil && mm_atomic.LoadUint64(&m.afterDeletePVZCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeletePVZInspect logs each unmet expectation
func (m *RepoMock) MinimockDeletePVZInspect() {
	for _, e := range m.DeletePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.DeletePVZ with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeletePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeletePVZCounter) < 1 {
		if m.DeletePVZMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.DeletePVZ")
		} else {
			m.t.Errorf("Expected call to RepoMock.DeletePVZ with params: %#v", *m.DeletePVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeletePVZ != nil && mm_atomic.LoadUint64(&m.afterDeletePVZCounter) < 1 {
		m.t.Error("Expected call to RepoMock.DeletePVZ")
	}
}

type mRepoMockGetPVZByID struct {
	mock               *RepoMock
	defaultExpectation *RepoMockGetPVZByIDExpectation
	expectations       []*RepoMockGetPVZByIDExpectation

	callArgs []*RepoMockGetPVZByIDParams
	mutex    sync.RWMutex
}

// RepoMockGetPVZByIDExpectation specifies expectation struct of the repo.GetPVZByID
type RepoMockGetPVZByIDExpectation struct {
	mock    *RepoMock
	params  *RepoMockGetPVZByIDParams
	results *RepoMockGetPVZByIDResults
	Counter uint64
}

// RepoMockGetPVZByIDParams contains parameters of the repo.GetPVZByID
type RepoMockGetPVZByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// RepoMockGetPVZByIDResults contains results of the repo.GetPVZByID
type RepoMockGetPVZByIDResults struct {
	p1  model.PVZ
	err error
}

// Expect sets up expected params for repo.GetPVZByID
func (mmGetPVZByID *mRepoMockGetPVZByID) Expect(ctx context.Context, id uuid.UUID) *mRepoMockGetPVZByID {
	if mmGetPVZByID.mock.funcGetPVZByID != nil {
		mmGetPVZByID.mock.t.Fatalf("RepoMock.GetPVZByID mock is already set by Set")
	}

	if mmGetPVZByID.defaultExpectation == nil {
		mmGetPVZByID.defaultExpectation = &RepoMockGetPVZByIDExpectation{}
	}

	mmGetPVZByID.defaultExpectation.params = &RepoMockGetPVZByIDParams{ctx, id}
	for _, e := range mmGetPVZByID.expectations {
		if minimock.Equal(e.params, mmGetPVZByID.defaultExpectation.params) {
			mmGetPVZByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetPVZByID.defaultExpectation.params)
		}
	}

	return mmGetPVZByID
}

// Inspect accepts an inspector function that has same arguments as the repo.GetPVZByID
func (mmGetPVZByID *mRepoMockGetPVZByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mRepoMockGetPVZByID {
	if mmGetPVZByID.mock.inspectFuncGetPVZByID != nil {
		mmGetPVZByID.mock.t.Fatalf("Inspect function is already set for RepoMock.GetPVZByID")
	}

	mmGetPVZByID.mock.inspectFuncGetPVZByID = f

	return mmGetPVZByID
}

// Return sets up results that will be returned by repo.GetPVZByID
func (mmGetPVZByID *mRepoMockGetPVZByID) Return(p1 model.PVZ, err error) *RepoMock {
	if mmGetPVZByID.mock.funcGetPVZByID != nil {
		mmGetPVZByID.mock.t.Fatalf("RepoMock.GetPVZByID mock is already set by Set")
	}

	if mmGetPVZByID.defaultExpectation == nil {
		mmGetPVZByID.defaultExpectation = &RepoMockGetPVZByIDExpectation{mock: mmGetPVZByID.mock}
	}
	mmGetPVZByID.defaultExpectation.results = &RepoMockGetPVZByIDResults{p1, err}
	return mmGetPVZByID.mock
}

// Set uses given function f to mock the repo.GetPVZByID method
func (mmGetPVZByID *mRepoMockGetPVZByID) Set(f func(ctx context.Context, id uuid.UUID) (p1 model.PVZ, err error)) *RepoMock {
	if mmGetPVZByID.defaultExpectation != nil {
		mmGetPVZByID.mock.t.Fatalf("Default expectation is already set for the repo.GetPVZByID method")
	}

	if len(mmGetPVZByID.expectations) > 0 {
		mmGetPVZByID.mock.t.Fatalf("Some expectations are already set for the repo.GetPVZByID method")
	}

	mmGetPVZByID.mock.funcGetPVZByID = f
	return mmGetPVZByID.mock
}

// When sets expectation for the repo.GetPVZByID which will trigger the result defined by the following
// Then helper
func (mmGetPVZByID *mRepoMockGetPVZByID) When(ctx context.Context, id uuid.UUID) *RepoMockGetPVZByIDExpectation {
	if mmGetPVZByID.mock.funcGetPVZByID != nil {
		mmGetPVZByID.mock.t.Fatalf("RepoMock.GetPVZByID mock is already set by Set")
	}

	expectation := &RepoMockGetPVZByIDExpectation{
		mock:   mmGetPVZByID.mock,
		params: &RepoMockGetPVZByIDParams{ctx, id},
	}
	mmGetPVZByID.expectations = append(mmGetPVZByID.expectations, expectation)
	return expectation
}

// Then sets up repo.GetPVZByID return parameters for the expectation previously defined by the When method
func (e *RepoMockGetPVZByIDExpectation) Then(p1 model.PVZ, err error) *RepoMock {
	e.results = &RepoMockGetPVZByIDResults{p1, err}
	return e.mock
}

// GetPVZByID implements pvz.repo
func (mmGetPVZByID *RepoMock) GetPVZByID(ctx context.Context, id uuid.UUID) (p1 model.PVZ, err error) {
	mm_atomic.AddUint64(&mmGetPVZByID.beforeGetPVZByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetPVZByID.afterGetPVZByIDCounter, 1)

	if mmGetPVZByID.inspectFuncGetPVZByID != nil {
		mmGetPVZByID.inspectFuncGetPVZByID(ctx, id)
	}

	mm_params := RepoMockGetPVZByIDParams{ctx, id}

	// Record call args
	mmGetPVZByID.GetPVZByIDMock.mutex.Lock()
	mmGetPVZByID.GetPVZByIDMock.callArgs = append(mmGetPVZByID.GetPVZByIDMock.callArgs, &mm_params)
	mmGetPVZByID.GetPVZByIDMock.mutex.Unlock()

	for _, e := range mmGetPVZByID.GetPVZByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.p1, e.results.err
		}
	}

	if mmGetPVZByID.GetPVZByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetPVZByID.GetPVZByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetPVZByID.GetPVZByIDMock.defaultExpectation.params
		mm_got := RepoMockGetPVZByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetPVZByID.t.Errorf("RepoMock.GetPVZByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetPVZByID.GetPVZByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetPVZByID.t.Fatal("No results are set for the RepoMock.GetPVZByID")
		}
		return (*mm_results).p1, (*mm_results).err
	}
	if mmGetPVZByID.funcGetPVZByID != nil {
		return mmGetPVZByID.funcGetPVZByID(ctx, id)
	}
	mmGetPVZByID.t.Fatalf("Unexpected call to RepoMock.GetPVZByID. %v %v", ctx, id)
	return
}

// GetPVZByIDAfterCounter returns a count of finished RepoMock.GetPVZByID invocations
func (mmGetPVZByID *RepoMock) GetPVZByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPVZByID.afterGetPVZByIDCounter)
}

// GetPVZByIDBeforeCounter returns a count of RepoMock.GetPVZByID invocations
func (mmGetPVZByID *RepoMock) GetPVZByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetPVZByID.beforeGetPVZByIDCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.GetPVZByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetPVZByID *mRepoMockGetPVZByID) Calls() []*RepoMockGetPVZByIDParams {
	mmGetPVZByID.mutex.RLock()

	argCopy := make([]*RepoMockGetPVZByIDParams, len(mmGetPVZByID.callArgs))
	copy(argCopy, mmGetPVZByID.callArgs)

	mmGetPVZByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetPVZByIDDone returns true if the count of the GetPVZByID invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockGetPVZByIDDone() bool {
	for _, e := range m.GetPVZByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPVZByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPVZByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPVZByID != nil && mm_atomic.LoadUint64(&m.afterGetPVZByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetPVZByIDInspect logs each unmet expectation
func (m *RepoMock) MinimockGetPVZByIDInspect() {
	for _, e := range m.GetPVZByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.GetPVZByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetPVZByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetPVZByIDCounter) < 1 {
		if m.GetPVZByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.GetPVZByID")
		} else {
			m.t.Errorf("Expected call to RepoMock.GetPVZByID with params: %#v", *m.GetPVZByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetPVZByID != nil && mm_atomic.LoadUint64(&m.afterGetPVZByIDCounter) < 1 {
		m.t.Error("Expected call to RepoMock.GetPVZByID")
	}
}

type mRepoMockListPVZs struct {
	mock               *RepoMock
	defaultExpectation *RepoMockListPVZsExpectation
	expectations       []*RepoMockListPVZsExpectation

	callArgs []*RepoMockListPVZsParams
	mutex    sync.RWMutex
}

// RepoMockListPVZsExpectation specifies expectation struct of the repo.ListPVZs
type RepoMockListPVZsExpectation struct {
	mock    *RepoMock
	params  *RepoMockListPVZsParams
	results *RepoMockListPVZsResults
	Counter uint64
}

// RepoMockListPVZsParams contains parameters of the repo.ListPVZs
type RepoMockListPVZsParams struct {
	ctx context.Context
}

// RepoMockListPVZsResults contains results of the repo.ListPVZs
type RepoMockListPVZsResults struct {
	pa1 []model.PVZ
	err error
}

// Expect sets up expected params for repo.ListPVZs
func (mmListPVZs *mRepoMockListPVZs) Expect(ctx context.Context) *mRepoMockListPVZs {
	if mmListPVZs.mock.funcListPVZs != nil {
		mmListPVZs.mock.t.Fatalf("RepoMock.ListPVZs mock is already set by Set")
	}

	if mmListPVZs.defaultExpectation == nil {
		mmListPVZs.defaultExpectation = &RepoMockListPVZsExpectation{}
	}

	mmListPVZs.defaultExpectation.params = &RepoMockListPVZsParams{ctx}
	for _, e := range mmListPVZs.expectations {
		if minimock.Equal(e.params, mmListPVZs.defaultExpectation.params) {
			mmListPVZs.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListPVZs.defaultExpectation.params)
		}
	}

	return mmListPVZs
}

// Inspect accepts an inspector function that has same arguments as the repo.ListPVZs
func (mmListPVZs *mRepoMockListPVZs) Inspect(f func(ctx context.Context)) *mRepoMockListPVZs {
	if mmListPVZs.mock.inspectFuncListPVZs != nil {
		mmListPVZs.mock.t.Fatalf("Inspect function is already set for RepoMock.ListPVZs")
	}

	mmListPVZs.mock.inspectFuncListPVZs = f

	return mmListPVZs
}

// Return sets up results that will be returned by repo.ListPVZs
func (mmListPVZs *mRepoMockListPVZs) Return(pa1 []model.PVZ, err error) *RepoMock {
	if mmListPVZs.mock.funcListPVZs != nil {
		mmListPVZs.mock.t.Fatalf("RepoMock.ListPVZs mock is already set by Set")
	}

	if mmListPVZs.defaultExpectation == nil {
		mmListPVZs.defaultExpectation = &RepoMockListPVZsExpectation{mock: mmListPVZs.mock}
	}
	mmListPVZs.defaultExpectation.results = &RepoMockListPVZsResults{pa1, err}
	return mmListPVZs.mock
}

// Set uses given function f to mock the repo.ListPVZs method
func (mmListPVZs *mRepoMockListPVZs) Set(f func(ctx context.Context) (pa1 []model.PVZ, err error)) *RepoMock {
	if mmListPVZs.defaultExpectation != nil {
		mmListPVZs.mock.t.Fatalf("Default expectation is already set for the repo.ListPVZs method")
	}

	if len(mmListPVZs.expectations) > 0 {
		mmListPVZs.mock.t.Fatalf("Some expectations are already set for the repo.ListPVZs method")
	}

	mmListPVZs.mock.funcListPVZs = f
	return mmListPVZs.mock
}

// When sets expectation for the repo.ListPVZs which will trigger the result defined by the following
// Then helper
func (mmListPVZs *mRepoMockListPVZs) When(ctx context.Context) *RepoMockListPVZsExpectation {
	if mmListPVZs.mock.funcListPVZs != nil {
		mmListPVZs.mock.t.Fatalf("RepoMock.ListPVZs mock is already set by Set")
	}

	expectation := &RepoMockListPVZsExpectation{
		mock:   mmListPVZs.mock,
		params: &RepoMockListPVZsParams{ctx},
	}
	mmListPVZs.expectations = append(mmListPVZs.expectations, expectation)
	return expectation
}

// Then sets up repo.ListPVZs return parameters for the expectation previously defined by the When method
func (e *RepoMockListPVZsExpectation) Then(pa1 []model.PVZ, err error) *RepoMock {
	e.results = &RepoMockListPVZsResults{pa1, err}
	return e.mock
}

// ListPVZs implements pvz.repo
func (mmListPVZs *RepoMock) ListPVZs(ctx context.Context) (pa1 []model.PVZ, err error) {
	mm_atomic.AddUint64(&mmListPVZs.beforeListPVZsCounter, 1)
	defer mm_atomic.AddUint64(&mmListPVZs.afterListPVZsCounter, 1)

	if mmListPVZs.inspectFuncListPVZs != nil {
		mmListPVZs.inspectFuncListPVZs(ctx)
	}

	mm_params := RepoMockListPVZsParams{ctx}

	// Record call args
	mmListPVZs.ListPVZsMock.mutex.Lock()
	mmListPVZs.ListPVZsMock.callArgs = append(mmListPVZs.ListPVZsMock.callArgs, &mm_params)
	mmListPVZs.ListPVZsMock.mutex.Unlock()

	for _, e := range mmListPVZs.ListPVZsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pa1, e.results.err
		}
	}

	if mmListPVZs.ListPVZsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPVZs.ListPVZsMock.defaultExpectation.Counter, 1)
		mm_want := mmListPVZs.ListPVZsMock.defaultExpectation.params
		mm_got := RepoMockListPVZsParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListPVZs.t.Errorf("RepoMock.ListPVZs got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListPVZs.ListPVZsMock.defaultExpectation.results
		if mm_results == nil {
			mmListPVZs.t.Fatal("No results are set for the RepoMock.ListPVZs")
		}
		return (*mm_results).pa1, (*mm_results).err
	}
	if mmListPVZs.funcListPVZs != nil {
		return mmListPVZs.funcListPVZs(ctx)
	}
	mmListPVZs.t.Fatalf("Unexpected call to RepoMock.ListPVZs. %v", ctx)
	return
}

// ListPVZsAfterCounter returns a count of finished RepoMock.ListPVZs invocations
func (mmListPVZs *RepoMock) ListPVZsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPVZs.afterListPVZsCounter)
}

// ListPVZsBeforeCounter returns a count of RepoMock.ListPVZs invocations
func (mmListPVZs *RepoMock) ListPVZsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPVZs.beforeListPVZsCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.ListPVZs.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListPVZs *mRepoMockListPVZs) Calls() []*RepoMockListPVZsParams {
	mmListPVZs.mutex.RLock()

	argCopy := make([]*RepoMockListPVZsParams, len(mmListPVZs.callArgs))
	copy(argCopy, mmListPVZs.callArgs)

	mmListPVZs.mutex.RUnlock()

	return argCopy
}

// MinimockListPVZsDone returns true if the count of the ListPVZs invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockListPVZsDone() bool {
	for _, e := range m.ListPVZsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListPVZsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListPVZsCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPVZs != nil && mm_atomic.LoadUint64(&m.afterListPVZsCounter) < 1 {
		return false
	}
	return true
}

// MinimockListPVZsInspect logs each unmet expectation
func (m *RepoMock) MinimockListPVZsInspect() {
	for _, e := range m.ListPVZsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.ListPVZs with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListPVZsMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListPVZsCounter) < 1 {
		if m.ListPVZsMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.ListPVZs")
		} else {
			m.t.Errorf("Expected call to RepoMock.ListPVZs with params: %#v", *m.ListPVZsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPVZs != nil && mm_atomic.LoadUint64(&m.afterListPVZsCounter) < 1 {
		m.t.Error("Expected call to RepoMock.ListPVZs")
	}
}

type mRepoMockUpdatePVZ struct {
	mock               *RepoMock
	defaultExpectation *RepoMockUpdatePVZExpectation
	expectations       []*RepoMockUpdatePVZExpectation

	callArgs []*RepoMockUpdatePVZParams
	mutex    sync.RWMutex
}

// RepoMockUpdatePVZExpectation specifies expectation struct of the repo.UpdatePVZ
type RepoMockUpdatePVZExpectation struct {
	mock    *RepoMock
	params  *RepoMockUpdatePVZParams
	results *RepoMockUpdatePVZResults
	Counter uint64
}

// RepoMockUpdatePVZParams contains parameters of the repo.UpdatePVZ
type RepoMockUpdatePVZParams struct {
	ctx    context.Context
	updPVZ model.PVZ
}

// RepoMockUpdatePVZResults contains results of the repo.UpdatePVZ
type RepoMockUpdatePVZResults struct {
	err error
}

// Expect sets up expected params for repo.UpdatePVZ
func (mmUpdatePVZ *mRepoMockUpdatePVZ) Expect(ctx context.Context, updPVZ model.PVZ) *mRepoMockUpdatePVZ {
	if mmUpdatePVZ.mock.funcUpdatePVZ != nil {
		mmUpdatePVZ.mock.t.Fatalf("RepoMock.UpdatePVZ mock is already set by Set")
	}

	if mmUpdatePVZ.defaultExpectation == nil {
		mmUpdatePVZ.defaultExpectation = &RepoMockUpdatePVZExpectation{}
	}

	mmUpdatePVZ.defaultExpectation.params = &RepoMockUpdatePVZParams{ctx, updPVZ}
	for _, e := range mmUpdatePVZ.expectations {
		if minimock.Equal(e.params, mmUpdatePVZ.defaultExpectation.params) {
			mmUpdatePVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdatePVZ.defaultExpectation.params)
		}
	}

	return mmUpdatePVZ
}

// Inspect accepts an inspector function that has same arguments as the repo.UpdatePVZ
func (mmUpdatePVZ *mRepoMockUpdatePVZ) Inspect(f func(ctx context.Context, updPVZ model.PVZ)) *mRepoMockUpdatePVZ {
	if mmUpdatePVZ.mock.inspectFuncUpdatePVZ != nil {
		mmUpdatePVZ.mock.t.Fatalf("Inspect function is already set for RepoMock.UpdatePVZ")
	}

	mmUpdatePVZ.mock.inspectFuncUpdatePVZ = f

	return mmUpdatePVZ
}

// Return sets up results that will be returned by repo.UpdatePVZ
func (mmUpdatePVZ *mRepoMockUpdatePVZ) Return(err error) *RepoMock {
	if mmUpdatePVZ.mock.funcUpdatePVZ != nil {
		mmUpdatePVZ.mock.t.Fatalf("RepoMock.UpdatePVZ mock is already set by Set")
	}

	if mmUpdatePVZ.defaultExpectation == nil {
		mmUpdatePVZ.defaultExpectation = &RepoMockUpdatePVZExpectation{mock: mmUpdatePVZ.mock}
	}
	mmUpdatePVZ.defaultExpectation.results = &RepoMockUpdatePVZResults{err}
	return mmUpdatePVZ.mock
}

// Set uses given function f to mock the repo.UpdatePVZ method
func (mmUpdatePVZ *mRepoMockUpdatePVZ) Set(f func(ctx context.Context, updPVZ model.PVZ) (err error)) *RepoMock {
	if mmUpdatePVZ.defaultExpectation != nil {
		mmUpdatePVZ.mock.t.Fatalf("Default expectation is already set for the repo.UpdatePVZ method")
	}

	if len(mmUpdatePVZ.expectations) > 0 {
		mmUpdatePVZ.mock.t.Fatalf("Some expectations are already set for the repo.UpdatePVZ method")
	}

	mmUpdatePVZ.mock.funcUpdatePVZ = f
	return mmUpdatePVZ.mock
}

// When sets expectation for the repo.UpdatePVZ which will trigger the result defined by the following
// Then helper
func (mmUpdatePVZ *mRepoMockUpdatePVZ) When(ctx context.Context, updPVZ model.PVZ) *RepoMockUpdatePVZExpectation {
	if mmUpdatePVZ.mock.funcUpdatePVZ != nil {
		mmUpdatePVZ.mock.t.Fatalf("RepoMock.UpdatePVZ mock is already set by Set")
	}

	expectation := &RepoMockUpdatePVZExpectation{
		mock:   mmUpdatePVZ.mock,
		params: &RepoMockUpdatePVZParams{ctx, updPVZ},
	}
	mmUpdatePVZ.expectations = append(mmUpdatePVZ.expectations, expectation)
	return expectation
}

// Then sets up repo.UpdatePVZ return parameters for the expectation previously defined by the When method
func (e *RepoMockUpdatePVZExpectation) Then(err error) *RepoMock {
	e.results = &RepoMockUpdatePVZResults{err}
	return e.mock
}

// UpdatePVZ implements pvz.repo
func (mmUpdatePVZ *RepoMock) UpdatePVZ(ctx context.Context, updPVZ model.PVZ) (err error) {
	mm_atomic.AddUint64(&mmUpdatePVZ.beforeUpdatePVZCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdatePVZ.afterUpdatePVZCounter, 1)

	if mmUpdatePVZ.inspectFuncUpdatePVZ != nil {
		mmUpdatePVZ.inspectFuncUpdatePVZ(ctx, updPVZ)
	}

	mm_params := RepoMockUpdatePVZParams{ctx, updPVZ}

	// Record call args
	mmUpdatePVZ.UpdatePVZMock.mutex.Lock()
	mmUpdatePVZ.UpdatePVZMock.callArgs = append(mmUpdatePVZ.UpdatePVZMock.callArgs, &mm_params)
	mmUpdatePVZ.UpdatePVZMock.mutex.Unlock()

	for _, e := range mmUpdatePVZ.UpdatePVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdatePVZ.UpdatePVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdatePVZ.UpdatePVZMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdatePVZ.UpdatePVZMock.defaultExpectation.params
		mm_got := RepoMockUpdatePVZParams{ctx, updPVZ}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdatePVZ.t.Errorf("RepoMock.UpdatePVZ got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdatePVZ.UpdatePVZMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdatePVZ.t.Fatal("No results are set for the RepoMock.UpdatePVZ")
		}
		return (*mm_results).err
	}
	if mmUpdatePVZ.funcUpdatePVZ != nil {
		return mmUpdatePVZ.funcUpdatePVZ(ctx, updPVZ)
	}
	mmUpdatePVZ.t.Fatalf("Unexpected call to RepoMock.UpdatePVZ. %v %v", ctx, updPVZ)
	return
}

// UpdatePVZAfterCounter returns a count of finished RepoMock.UpdatePVZ invocations
func (mmUpdatePVZ *RepoMock) UpdatePVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePVZ.afterUpdatePVZCounter)
}

// UpdatePVZBeforeCounter returns a count of RepoMock.UpdatePVZ invocations
func (mmUpdatePVZ *RepoMock) UpdatePVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdatePVZ.beforeUpdatePVZCounter)
}

// Calls returns a list of arguments used in each call to RepoMock.UpdatePVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdatePVZ *mRepoMockUpdatePVZ) Calls() []*RepoMockUpdatePVZParams {
	mmUpdatePVZ.mutex.RLock()

	argCopy := make([]*RepoMockUpdatePVZParams, len(mmUpdatePVZ.callArgs))
	copy(argCopy, mmUpdatePVZ.callArgs)

	mmUpdatePVZ.mutex.RUnlock()

	return argCopy
}

// MinimockUpdatePVZDone returns true if the count of the UpdatePVZ invocations corresponds
// the number of defined expectations
func (m *RepoMock) MinimockUpdatePVZDone() bool {
	for _, e := range m.UpdatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatePVZCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePVZ != nil && mm_atomic.LoadUint64(&m.afterUpdatePVZCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdatePVZInspect logs each unmet expectation
func (m *RepoMock) MinimockUpdatePVZInspect() {
	for _, e := range m.UpdatePVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepoMock.UpdatePVZ with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdatePVZMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdatePVZCounter) < 1 {
		if m.UpdatePVZMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to RepoMock.UpdatePVZ")
		} else {
			m.t.Errorf("Expected call to RepoMock.UpdatePVZ with params: %#v", *m.UpdatePVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdatePVZ != nil && mm_atomic.LoadUint64(&m.afterUpdatePVZCounter) < 1 {
		m.t.Error("Expected call to RepoMock.UpdatePVZ")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepoMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreatePVZInspect()

			m.MinimockDeletePVZInspect()

			m.MinimockGetPVZByIDInspect()

			m.MinimockListPVZsInspect()

			m.MinimockUpdatePVZInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepoMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepoMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreatePVZDone() &&
		m.MinimockDeletePVZDone() &&
		m.MinimockGetPVZByIDDone() &&
		m.MinimockListPVZsDone() &&
		m.MinimockUpdatePVZDone()
}

// Code generated by http://github.com/gojuno/minimock (dev). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
	"gitlab.ozon.dev/zlatoivan4/homework/internal/model"
)

// ServiceMock implements order.service
type ServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateOrder          func(ctx context.Context, order model.Order) (u1 uuid.UUID, err error)
	inspectFuncCreateOrder   func(ctx context.Context, order model.Order)
	afterCreateOrderCounter  uint64
	beforeCreateOrderCounter uint64
	CreateOrderMock          mServiceMockCreateOrder

	funcDeleteOrder          func(ctx context.Context, id uuid.UUID) (err error)
	inspectFuncDeleteOrder   func(ctx context.Context, id uuid.UUID)
	afterDeleteOrderCounter  uint64
	beforeDeleteOrderCounter uint64
	DeleteOrderMock          mServiceMockDeleteOrder

	funcGetOrderByID          func(ctx context.Context, id uuid.UUID) (o1 model.Order, err error)
	inspectFuncGetOrderByID   func(ctx context.Context, id uuid.UUID)
	afterGetOrderByIDCounter  uint64
	beforeGetOrderByIDCounter uint64
	GetOrderByIDMock          mServiceMockGetOrderByID

	funcGiveOutOrders          func(ctx context.Context, id uuid.UUID, ids []uuid.UUID) (err error)
	inspectFuncGiveOutOrders   func(ctx context.Context, id uuid.UUID, ids []uuid.UUID)
	afterGiveOutOrdersCounter  uint64
	beforeGiveOutOrdersCounter uint64
	GiveOutOrdersMock          mServiceMockGiveOutOrders

	funcListClientOrders          func(ctx context.Context, id uuid.UUID) (oa1 []model.Order, err error)
	inspectFuncListClientOrders   func(ctx context.Context, id uuid.UUID)
	afterListClientOrdersCounter  uint64
	beforeListClientOrdersCounter uint64
	ListClientOrdersMock          mServiceMockListClientOrders

	funcListOrders          func(ctx context.Context) (oa1 []model.Order, err error)
	inspectFuncListOrders   func(ctx context.Context)
	afterListOrdersCounter  uint64
	beforeListOrdersCounter uint64
	ListOrdersMock          mServiceMockListOrders

	funcListReturnedOrders          func(ctx context.Context) (oa1 []model.Order, err error)
	inspectFuncListReturnedOrders   func(ctx context.Context)
	afterListReturnedOrdersCounter  uint64
	beforeListReturnedOrdersCounter uint64
	ListReturnedOrdersMock          mServiceMockListReturnedOrders

	funcReturnOrder          func(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error)
	inspectFuncReturnOrder   func(ctx context.Context, clientID uuid.UUID, id uuid.UUID)
	afterReturnOrderCounter  uint64
	beforeReturnOrderCounter uint64
	ReturnOrderMock          mServiceMockReturnOrder

	funcUpdateOrder          func(ctx context.Context, updPVZ model.Order) (err error)
	inspectFuncUpdateOrder   func(ctx context.Context, updPVZ model.Order)
	afterUpdateOrderCounter  uint64
	beforeUpdateOrderCounter uint64
	UpdateOrderMock          mServiceMockUpdateOrder
}

// NewServiceMock returns a mock for order.service
func NewServiceMock(t minimock.Tester) *ServiceMock {
	m := &ServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateOrderMock = mServiceMockCreateOrder{mock: m}
	m.CreateOrderMock.callArgs = []*ServiceMockCreateOrderParams{}

	m.DeleteOrderMock = mServiceMockDeleteOrder{mock: m}
	m.DeleteOrderMock.callArgs = []*ServiceMockDeleteOrderParams{}

	m.GetOrderByIDMock = mServiceMockGetOrderByID{mock: m}
	m.GetOrderByIDMock.callArgs = []*ServiceMockGetOrderByIDParams{}

	m.GiveOutOrdersMock = mServiceMockGiveOutOrders{mock: m}
	m.GiveOutOrdersMock.callArgs = []*ServiceMockGiveOutOrdersParams{}

	m.ListClientOrdersMock = mServiceMockListClientOrders{mock: m}
	m.ListClientOrdersMock.callArgs = []*ServiceMockListClientOrdersParams{}

	m.ListOrdersMock = mServiceMockListOrders{mock: m}
	m.ListOrdersMock.callArgs = []*ServiceMockListOrdersParams{}

	m.ListReturnedOrdersMock = mServiceMockListReturnedOrders{mock: m}
	m.ListReturnedOrdersMock.callArgs = []*ServiceMockListReturnedOrdersParams{}

	m.ReturnOrderMock = mServiceMockReturnOrder{mock: m}
	m.ReturnOrderMock.callArgs = []*ServiceMockReturnOrderParams{}

	m.UpdateOrderMock = mServiceMockUpdateOrder{mock: m}
	m.UpdateOrderMock.callArgs = []*ServiceMockUpdateOrderParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mServiceMockCreateOrder struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockCreateOrderExpectation
	expectations       []*ServiceMockCreateOrderExpectation

	callArgs []*ServiceMockCreateOrderParams
	mutex    sync.RWMutex
}

// ServiceMockCreateOrderExpectation specifies expectation struct of the service.CreateOrder
type ServiceMockCreateOrderExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockCreateOrderParams
	results *ServiceMockCreateOrderResults
	Counter uint64
}

// ServiceMockCreateOrderParams contains parameters of the service.CreateOrder
type ServiceMockCreateOrderParams struct {
	ctx   context.Context
	order model.Order
}

// ServiceMockCreateOrderResults contains results of the service.CreateOrder
type ServiceMockCreateOrderResults struct {
	u1  uuid.UUID
	err error
}

// Expect sets up expected params for service.CreateOrder
func (mmCreateOrder *mServiceMockCreateOrder) Expect(ctx context.Context, order model.Order) *mServiceMockCreateOrder {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ServiceMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &ServiceMockCreateOrderExpectation{}
	}

	mmCreateOrder.defaultExpectation.params = &ServiceMockCreateOrderParams{ctx, order}
	for _, e := range mmCreateOrder.expectations {
		if minimock.Equal(e.params, mmCreateOrder.defaultExpectation.params) {
			mmCreateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateOrder.defaultExpectation.params)
		}
	}

	return mmCreateOrder
}

// Inspect accepts an inspector function that has same arguments as the service.CreateOrder
func (mmCreateOrder *mServiceMockCreateOrder) Inspect(f func(ctx context.Context, order model.Order)) *mServiceMockCreateOrder {
	if mmCreateOrder.mock.inspectFuncCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("Inspect function is already set for ServiceMock.CreateOrder")
	}

	mmCreateOrder.mock.inspectFuncCreateOrder = f

	return mmCreateOrder
}

// Return sets up results that will be returned by service.CreateOrder
func (mmCreateOrder *mServiceMockCreateOrder) Return(u1 uuid.UUID, err error) *ServiceMock {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ServiceMock.CreateOrder mock is already set by Set")
	}

	if mmCreateOrder.defaultExpectation == nil {
		mmCreateOrder.defaultExpectation = &ServiceMockCreateOrderExpectation{mock: mmCreateOrder.mock}
	}
	mmCreateOrder.defaultExpectation.results = &ServiceMockCreateOrderResults{u1, err}
	return mmCreateOrder.mock
}

// Set uses given function f to mock the service.CreateOrder method
func (mmCreateOrder *mServiceMockCreateOrder) Set(f func(ctx context.Context, order model.Order) (u1 uuid.UUID, err error)) *ServiceMock {
	if mmCreateOrder.defaultExpectation != nil {
		mmCreateOrder.mock.t.Fatalf("Default expectation is already set for the service.CreateOrder method")
	}

	if len(mmCreateOrder.expectations) > 0 {
		mmCreateOrder.mock.t.Fatalf("Some expectations are already set for the service.CreateOrder method")
	}

	mmCreateOrder.mock.funcCreateOrder = f
	return mmCreateOrder.mock
}

// When sets expectation for the service.CreateOrder which will trigger the result defined by the following
// Then helper
func (mmCreateOrder *mServiceMockCreateOrder) When(ctx context.Context, order model.Order) *ServiceMockCreateOrderExpectation {
	if mmCreateOrder.mock.funcCreateOrder != nil {
		mmCreateOrder.mock.t.Fatalf("ServiceMock.CreateOrder mock is already set by Set")
	}

	expectation := &ServiceMockCreateOrderExpectation{
		mock:   mmCreateOrder.mock,
		params: &ServiceMockCreateOrderParams{ctx, order},
	}
	mmCreateOrder.expectations = append(mmCreateOrder.expectations, expectation)
	return expectation
}

// Then sets up service.CreateOrder return parameters for the expectation previously defined by the When method
func (e *ServiceMockCreateOrderExpectation) Then(u1 uuid.UUID, err error) *ServiceMock {
	e.results = &ServiceMockCreateOrderResults{u1, err}
	return e.mock
}

// CreateOrder implements order.service
func (mmCreateOrder *ServiceMock) CreateOrder(ctx context.Context, order model.Order) (u1 uuid.UUID, err error) {
	mm_atomic.AddUint64(&mmCreateOrder.beforeCreateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateOrder.afterCreateOrderCounter, 1)

	if mmCreateOrder.inspectFuncCreateOrder != nil {
		mmCreateOrder.inspectFuncCreateOrder(ctx, order)
	}

	mm_params := ServiceMockCreateOrderParams{ctx, order}

	// Record call args
	mmCreateOrder.CreateOrderMock.mutex.Lock()
	mmCreateOrder.CreateOrderMock.callArgs = append(mmCreateOrder.CreateOrderMock.callArgs, &mm_params)
	mmCreateOrder.CreateOrderMock.mutex.Unlock()

	for _, e := range mmCreateOrder.CreateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.u1, e.results.err
		}
	}

	if mmCreateOrder.CreateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateOrder.CreateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateOrder.CreateOrderMock.defaultExpectation.params
		mm_got := ServiceMockCreateOrderParams{ctx, order}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateOrder.t.Errorf("ServiceMock.CreateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateOrder.CreateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateOrder.t.Fatal("No results are set for the ServiceMock.CreateOrder")
		}
		return (*mm_results).u1, (*mm_results).err
	}
	if mmCreateOrder.funcCreateOrder != nil {
		return mmCreateOrder.funcCreateOrder(ctx, order)
	}
	mmCreateOrder.t.Fatalf("Unexpected call to ServiceMock.CreateOrder. %v %v", ctx, order)
	return
}

// CreateOrderAfterCounter returns a count of finished ServiceMock.CreateOrder invocations
func (mmCreateOrder *ServiceMock) CreateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.afterCreateOrderCounter)
}

// CreateOrderBeforeCounter returns a count of ServiceMock.CreateOrder invocations
func (mmCreateOrder *ServiceMock) CreateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateOrder.beforeCreateOrderCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.CreateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateOrder *mServiceMockCreateOrder) Calls() []*ServiceMockCreateOrderParams {
	mmCreateOrder.mutex.RLock()

	argCopy := make([]*ServiceMockCreateOrderParams, len(mmCreateOrder.callArgs))
	copy(argCopy, mmCreateOrder.callArgs)

	mmCreateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockCreateOrderDone returns true if the count of the CreateOrder invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockCreateOrderDone() bool {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockCreateOrderInspect logs each unmet expectation
func (m *ServiceMock) MinimockCreateOrderInspect() {
	for _, e := range m.CreateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.CreateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CreateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		if m.CreateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.CreateOrder")
		} else {
			m.t.Errorf("Expected call to ServiceMock.CreateOrder with params: %#v", *m.CreateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateOrder != nil && mm_atomic.LoadUint64(&m.afterCreateOrderCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.CreateOrder")
	}
}

type mServiceMockDeleteOrder struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockDeleteOrderExpectation
	expectations       []*ServiceMockDeleteOrderExpectation

	callArgs []*ServiceMockDeleteOrderParams
	mutex    sync.RWMutex
}

// ServiceMockDeleteOrderExpectation specifies expectation struct of the service.DeleteOrder
type ServiceMockDeleteOrderExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockDeleteOrderParams
	results *ServiceMockDeleteOrderResults
	Counter uint64
}

// ServiceMockDeleteOrderParams contains parameters of the service.DeleteOrder
type ServiceMockDeleteOrderParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockDeleteOrderResults contains results of the service.DeleteOrder
type ServiceMockDeleteOrderResults struct {
	err error
}

// Expect sets up expected params for service.DeleteOrder
func (mmDeleteOrder *mServiceMockDeleteOrder) Expect(ctx context.Context, id uuid.UUID) *mServiceMockDeleteOrder {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("ServiceMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &ServiceMockDeleteOrderExpectation{}
	}

	mmDeleteOrder.defaultExpectation.params = &ServiceMockDeleteOrderParams{ctx, id}
	for _, e := range mmDeleteOrder.expectations {
		if minimock.Equal(e.params, mmDeleteOrder.defaultExpectation.params) {
			mmDeleteOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteOrder.defaultExpectation.params)
		}
	}

	return mmDeleteOrder
}

// Inspect accepts an inspector function that has same arguments as the service.DeleteOrder
func (mmDeleteOrder *mServiceMockDeleteOrder) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockDeleteOrder {
	if mmDeleteOrder.mock.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("Inspect function is already set for ServiceMock.DeleteOrder")
	}

	mmDeleteOrder.mock.inspectFuncDeleteOrder = f

	return mmDeleteOrder
}

// Return sets up results that will be returned by service.DeleteOrder
func (mmDeleteOrder *mServiceMockDeleteOrder) Return(err error) *ServiceMock {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("ServiceMock.DeleteOrder mock is already set by Set")
	}

	if mmDeleteOrder.defaultExpectation == nil {
		mmDeleteOrder.defaultExpectation = &ServiceMockDeleteOrderExpectation{mock: mmDeleteOrder.mock}
	}
	mmDeleteOrder.defaultExpectation.results = &ServiceMockDeleteOrderResults{err}
	return mmDeleteOrder.mock
}

// Set uses given function f to mock the service.DeleteOrder method
func (mmDeleteOrder *mServiceMockDeleteOrder) Set(f func(ctx context.Context, id uuid.UUID) (err error)) *ServiceMock {
	if mmDeleteOrder.defaultExpectation != nil {
		mmDeleteOrder.mock.t.Fatalf("Default expectation is already set for the service.DeleteOrder method")
	}

	if len(mmDeleteOrder.expectations) > 0 {
		mmDeleteOrder.mock.t.Fatalf("Some expectations are already set for the service.DeleteOrder method")
	}

	mmDeleteOrder.mock.funcDeleteOrder = f
	return mmDeleteOrder.mock
}

// When sets expectation for the service.DeleteOrder which will trigger the result defined by the following
// Then helper
func (mmDeleteOrder *mServiceMockDeleteOrder) When(ctx context.Context, id uuid.UUID) *ServiceMockDeleteOrderExpectation {
	if mmDeleteOrder.mock.funcDeleteOrder != nil {
		mmDeleteOrder.mock.t.Fatalf("ServiceMock.DeleteOrder mock is already set by Set")
	}

	expectation := &ServiceMockDeleteOrderExpectation{
		mock:   mmDeleteOrder.mock,
		params: &ServiceMockDeleteOrderParams{ctx, id},
	}
	mmDeleteOrder.expectations = append(mmDeleteOrder.expectations, expectation)
	return expectation
}

// Then sets up service.DeleteOrder return parameters for the expectation previously defined by the When method
func (e *ServiceMockDeleteOrderExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockDeleteOrderResults{err}
	return e.mock
}

// DeleteOrder implements order.service
func (mmDeleteOrder *ServiceMock) DeleteOrder(ctx context.Context, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteOrder.beforeDeleteOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteOrder.afterDeleteOrderCounter, 1)

	if mmDeleteOrder.inspectFuncDeleteOrder != nil {
		mmDeleteOrder.inspectFuncDeleteOrder(ctx, id)
	}

	mm_params := ServiceMockDeleteOrderParams{ctx, id}

	// Record call args
	mmDeleteOrder.DeleteOrderMock.mutex.Lock()
	mmDeleteOrder.DeleteOrderMock.callArgs = append(mmDeleteOrder.DeleteOrderMock.callArgs, &mm_params)
	mmDeleteOrder.DeleteOrderMock.mutex.Unlock()

	for _, e := range mmDeleteOrder.DeleteOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteOrder.DeleteOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteOrder.DeleteOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteOrder.DeleteOrderMock.defaultExpectation.params
		mm_got := ServiceMockDeleteOrderParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteOrder.t.Errorf("ServiceMock.DeleteOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteOrder.DeleteOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteOrder.t.Fatal("No results are set for the ServiceMock.DeleteOrder")
		}
		return (*mm_results).err
	}
	if mmDeleteOrder.funcDeleteOrder != nil {
		return mmDeleteOrder.funcDeleteOrder(ctx, id)
	}
	mmDeleteOrder.t.Fatalf("Unexpected call to ServiceMock.DeleteOrder. %v %v", ctx, id)
	return
}

// DeleteOrderAfterCounter returns a count of finished ServiceMock.DeleteOrder invocations
func (mmDeleteOrder *ServiceMock) DeleteOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.afterDeleteOrderCounter)
}

// DeleteOrderBeforeCounter returns a count of ServiceMock.DeleteOrder invocations
func (mmDeleteOrder *ServiceMock) DeleteOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteOrder.beforeDeleteOrderCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.DeleteOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteOrder *mServiceMockDeleteOrder) Calls() []*ServiceMockDeleteOrderParams {
	mmDeleteOrder.mutex.RLock()

	argCopy := make([]*ServiceMockDeleteOrderParams, len(mmDeleteOrder.callArgs))
	copy(argCopy, mmDeleteOrder.callArgs)

	mmDeleteOrder.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteOrderDone returns true if the count of the DeleteOrder invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockDeleteOrderDone() bool {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteOrderInspect logs each unmet expectation
func (m *ServiceMock) MinimockDeleteOrderInspect() {
	for _, e := range m.DeleteOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.DeleteOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		if m.DeleteOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.DeleteOrder")
		} else {
			m.t.Errorf("Expected call to ServiceMock.DeleteOrder with params: %#v", *m.DeleteOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteOrder != nil && mm_atomic.LoadUint64(&m.afterDeleteOrderCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.DeleteOrder")
	}
}

type mServiceMockGetOrderByID struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockGetOrderByIDExpectation
	expectations       []*ServiceMockGetOrderByIDExpectation

	callArgs []*ServiceMockGetOrderByIDParams
	mutex    sync.RWMutex
}

// ServiceMockGetOrderByIDExpectation specifies expectation struct of the service.GetOrderByID
type ServiceMockGetOrderByIDExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockGetOrderByIDParams
	results *ServiceMockGetOrderByIDResults
	Counter uint64
}

// ServiceMockGetOrderByIDParams contains parameters of the service.GetOrderByID
type ServiceMockGetOrderByIDParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockGetOrderByIDResults contains results of the service.GetOrderByID
type ServiceMockGetOrderByIDResults struct {
	o1  model.Order
	err error
}

// Expect sets up expected params for service.GetOrderByID
func (mmGetOrderByID *mServiceMockGetOrderByID) Expect(ctx context.Context, id uuid.UUID) *mServiceMockGetOrderByID {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("ServiceMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &ServiceMockGetOrderByIDExpectation{}
	}

	mmGetOrderByID.defaultExpectation.params = &ServiceMockGetOrderByIDParams{ctx, id}
	for _, e := range mmGetOrderByID.expectations {
		if minimock.Equal(e.params, mmGetOrderByID.defaultExpectation.params) {
			mmGetOrderByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetOrderByID.defaultExpectation.params)
		}
	}

	return mmGetOrderByID
}

// Inspect accepts an inspector function that has same arguments as the service.GetOrderByID
func (mmGetOrderByID *mServiceMockGetOrderByID) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockGetOrderByID {
	if mmGetOrderByID.mock.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("Inspect function is already set for ServiceMock.GetOrderByID")
	}

	mmGetOrderByID.mock.inspectFuncGetOrderByID = f

	return mmGetOrderByID
}

// Return sets up results that will be returned by service.GetOrderByID
func (mmGetOrderByID *mServiceMockGetOrderByID) Return(o1 model.Order, err error) *ServiceMock {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("ServiceMock.GetOrderByID mock is already set by Set")
	}

	if mmGetOrderByID.defaultExpectation == nil {
		mmGetOrderByID.defaultExpectation = &ServiceMockGetOrderByIDExpectation{mock: mmGetOrderByID.mock}
	}
	mmGetOrderByID.defaultExpectation.results = &ServiceMockGetOrderByIDResults{o1, err}
	return mmGetOrderByID.mock
}

// Set uses given function f to mock the service.GetOrderByID method
func (mmGetOrderByID *mServiceMockGetOrderByID) Set(f func(ctx context.Context, id uuid.UUID) (o1 model.Order, err error)) *ServiceMock {
	if mmGetOrderByID.defaultExpectation != nil {
		mmGetOrderByID.mock.t.Fatalf("Default expectation is already set for the service.GetOrderByID method")
	}

	if len(mmGetOrderByID.expectations) > 0 {
		mmGetOrderByID.mock.t.Fatalf("Some expectations are already set for the service.GetOrderByID method")
	}

	mmGetOrderByID.mock.funcGetOrderByID = f
	return mmGetOrderByID.mock
}

// When sets expectation for the service.GetOrderByID which will trigger the result defined by the following
// Then helper
func (mmGetOrderByID *mServiceMockGetOrderByID) When(ctx context.Context, id uuid.UUID) *ServiceMockGetOrderByIDExpectation {
	if mmGetOrderByID.mock.funcGetOrderByID != nil {
		mmGetOrderByID.mock.t.Fatalf("ServiceMock.GetOrderByID mock is already set by Set")
	}

	expectation := &ServiceMockGetOrderByIDExpectation{
		mock:   mmGetOrderByID.mock,
		params: &ServiceMockGetOrderByIDParams{ctx, id},
	}
	mmGetOrderByID.expectations = append(mmGetOrderByID.expectations, expectation)
	return expectation
}

// Then sets up service.GetOrderByID return parameters for the expectation previously defined by the When method
func (e *ServiceMockGetOrderByIDExpectation) Then(o1 model.Order, err error) *ServiceMock {
	e.results = &ServiceMockGetOrderByIDResults{o1, err}
	return e.mock
}

// GetOrderByID implements order.service
func (mmGetOrderByID *ServiceMock) GetOrderByID(ctx context.Context, id uuid.UUID) (o1 model.Order, err error) {
	mm_atomic.AddUint64(&mmGetOrderByID.beforeGetOrderByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetOrderByID.afterGetOrderByIDCounter, 1)

	if mmGetOrderByID.inspectFuncGetOrderByID != nil {
		mmGetOrderByID.inspectFuncGetOrderByID(ctx, id)
	}

	mm_params := ServiceMockGetOrderByIDParams{ctx, id}

	// Record call args
	mmGetOrderByID.GetOrderByIDMock.mutex.Lock()
	mmGetOrderByID.GetOrderByIDMock.callArgs = append(mmGetOrderByID.GetOrderByIDMock.callArgs, &mm_params)
	mmGetOrderByID.GetOrderByIDMock.mutex.Unlock()

	for _, e := range mmGetOrderByID.GetOrderByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmGetOrderByID.GetOrderByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetOrderByID.GetOrderByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.params
		mm_got := ServiceMockGetOrderByIDParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetOrderByID.t.Errorf("ServiceMock.GetOrderByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetOrderByID.GetOrderByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetOrderByID.t.Fatal("No results are set for the ServiceMock.GetOrderByID")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmGetOrderByID.funcGetOrderByID != nil {
		return mmGetOrderByID.funcGetOrderByID(ctx, id)
	}
	mmGetOrderByID.t.Fatalf("Unexpected call to ServiceMock.GetOrderByID. %v %v", ctx, id)
	return
}

// GetOrderByIDAfterCounter returns a count of finished ServiceMock.GetOrderByID invocations
func (mmGetOrderByID *ServiceMock) GetOrderByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.afterGetOrderByIDCounter)
}

// GetOrderByIDBeforeCounter returns a count of ServiceMock.GetOrderByID invocations
func (mmGetOrderByID *ServiceMock) GetOrderByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetOrderByID.beforeGetOrderByIDCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GetOrderByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetOrderByID *mServiceMockGetOrderByID) Calls() []*ServiceMockGetOrderByIDParams {
	mmGetOrderByID.mutex.RLock()

	argCopy := make([]*ServiceMockGetOrderByIDParams, len(mmGetOrderByID.callArgs))
	copy(argCopy, mmGetOrderByID.callArgs)

	mmGetOrderByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetOrderByIDDone returns true if the count of the GetOrderByID invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGetOrderByIDDone() bool {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetOrderByIDInspect logs each unmet expectation
func (m *ServiceMock) MinimockGetOrderByIDInspect() {
	for _, e := range m.GetOrderByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GetOrderByID with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetOrderByIDMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		if m.GetOrderByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.GetOrderByID")
		} else {
			m.t.Errorf("Expected call to ServiceMock.GetOrderByID with params: %#v", *m.GetOrderByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetOrderByID != nil && mm_atomic.LoadUint64(&m.afterGetOrderByIDCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.GetOrderByID")
	}
}

type mServiceMockGiveOutOrders struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockGiveOutOrdersExpectation
	expectations       []*ServiceMockGiveOutOrdersExpectation

	callArgs []*ServiceMockGiveOutOrdersParams
	mutex    sync.RWMutex
}

// ServiceMockGiveOutOrdersExpectation specifies expectation struct of the service.GiveOutOrders
type ServiceMockGiveOutOrdersExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockGiveOutOrdersParams
	results *ServiceMockGiveOutOrdersResults
	Counter uint64
}

// ServiceMockGiveOutOrdersParams contains parameters of the service.GiveOutOrders
type ServiceMockGiveOutOrdersParams struct {
	ctx context.Context
	id  uuid.UUID
	ids []uuid.UUID
}

// ServiceMockGiveOutOrdersResults contains results of the service.GiveOutOrders
type ServiceMockGiveOutOrdersResults struct {
	err error
}

// Expect sets up expected params for service.GiveOutOrders
func (mmGiveOutOrders *mServiceMockGiveOutOrders) Expect(ctx context.Context, id uuid.UUID, ids []uuid.UUID) *mServiceMockGiveOutOrders {
	if mmGiveOutOrders.mock.funcGiveOutOrders != nil {
		mmGiveOutOrders.mock.t.Fatalf("ServiceMock.GiveOutOrders mock is already set by Set")
	}

	if mmGiveOutOrders.defaultExpectation == nil {
		mmGiveOutOrders.defaultExpectation = &ServiceMockGiveOutOrdersExpectation{}
	}

	mmGiveOutOrders.defaultExpectation.params = &ServiceMockGiveOutOrdersParams{ctx, id, ids}
	for _, e := range mmGiveOutOrders.expectations {
		if minimock.Equal(e.params, mmGiveOutOrders.defaultExpectation.params) {
			mmGiveOutOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGiveOutOrders.defaultExpectation.params)
		}
	}

	return mmGiveOutOrders
}

// Inspect accepts an inspector function that has same arguments as the service.GiveOutOrders
func (mmGiveOutOrders *mServiceMockGiveOutOrders) Inspect(f func(ctx context.Context, id uuid.UUID, ids []uuid.UUID)) *mServiceMockGiveOutOrders {
	if mmGiveOutOrders.mock.inspectFuncGiveOutOrders != nil {
		mmGiveOutOrders.mock.t.Fatalf("Inspect function is already set for ServiceMock.GiveOutOrders")
	}

	mmGiveOutOrders.mock.inspectFuncGiveOutOrders = f

	return mmGiveOutOrders
}

// Return sets up results that will be returned by service.GiveOutOrders
func (mmGiveOutOrders *mServiceMockGiveOutOrders) Return(err error) *ServiceMock {
	if mmGiveOutOrders.mock.funcGiveOutOrders != nil {
		mmGiveOutOrders.mock.t.Fatalf("ServiceMock.GiveOutOrders mock is already set by Set")
	}

	if mmGiveOutOrders.defaultExpectation == nil {
		mmGiveOutOrders.defaultExpectation = &ServiceMockGiveOutOrdersExpectation{mock: mmGiveOutOrders.mock}
	}
	mmGiveOutOrders.defaultExpectation.results = &ServiceMockGiveOutOrdersResults{err}
	return mmGiveOutOrders.mock
}

// Set uses given function f to mock the service.GiveOutOrders method
func (mmGiveOutOrders *mServiceMockGiveOutOrders) Set(f func(ctx context.Context, id uuid.UUID, ids []uuid.UUID) (err error)) *ServiceMock {
	if mmGiveOutOrders.defaultExpectation != nil {
		mmGiveOutOrders.mock.t.Fatalf("Default expectation is already set for the service.GiveOutOrders method")
	}

	if len(mmGiveOutOrders.expectations) > 0 {
		mmGiveOutOrders.mock.t.Fatalf("Some expectations are already set for the service.GiveOutOrders method")
	}

	mmGiveOutOrders.mock.funcGiveOutOrders = f
	return mmGiveOutOrders.mock
}

// When sets expectation for the service.GiveOutOrders which will trigger the result defined by the following
// Then helper
func (mmGiveOutOrders *mServiceMockGiveOutOrders) When(ctx context.Context, id uuid.UUID, ids []uuid.UUID) *ServiceMockGiveOutOrdersExpectation {
	if mmGiveOutOrders.mock.funcGiveOutOrders != nil {
		mmGiveOutOrders.mock.t.Fatalf("ServiceMock.GiveOutOrders mock is already set by Set")
	}

	expectation := &ServiceMockGiveOutOrdersExpectation{
		mock:   mmGiveOutOrders.mock,
		params: &ServiceMockGiveOutOrdersParams{ctx, id, ids},
	}
	mmGiveOutOrders.expectations = append(mmGiveOutOrders.expectations, expectation)
	return expectation
}

// Then sets up service.GiveOutOrders return parameters for the expectation previously defined by the When method
func (e *ServiceMockGiveOutOrdersExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockGiveOutOrdersResults{err}
	return e.mock
}

// GiveOutOrders implements order.service
func (mmGiveOutOrders *ServiceMock) GiveOutOrders(ctx context.Context, id uuid.UUID, ids []uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmGiveOutOrders.beforeGiveOutOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmGiveOutOrders.afterGiveOutOrdersCounter, 1)

	if mmGiveOutOrders.inspectFuncGiveOutOrders != nil {
		mmGiveOutOrders.inspectFuncGiveOutOrders(ctx, id, ids)
	}

	mm_params := ServiceMockGiveOutOrdersParams{ctx, id, ids}

	// Record call args
	mmGiveOutOrders.GiveOutOrdersMock.mutex.Lock()
	mmGiveOutOrders.GiveOutOrdersMock.callArgs = append(mmGiveOutOrders.GiveOutOrdersMock.callArgs, &mm_params)
	mmGiveOutOrders.GiveOutOrdersMock.mutex.Unlock()

	for _, e := range mmGiveOutOrders.GiveOutOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmGiveOutOrders.GiveOutOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGiveOutOrders.GiveOutOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmGiveOutOrders.GiveOutOrdersMock.defaultExpectation.params
		mm_got := ServiceMockGiveOutOrdersParams{ctx, id, ids}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGiveOutOrders.t.Errorf("ServiceMock.GiveOutOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGiveOutOrders.GiveOutOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmGiveOutOrders.t.Fatal("No results are set for the ServiceMock.GiveOutOrders")
		}
		return (*mm_results).err
	}
	if mmGiveOutOrders.funcGiveOutOrders != nil {
		return mmGiveOutOrders.funcGiveOutOrders(ctx, id, ids)
	}
	mmGiveOutOrders.t.Fatalf("Unexpected call to ServiceMock.GiveOutOrders. %v %v %v", ctx, id, ids)
	return
}

// GiveOutOrdersAfterCounter returns a count of finished ServiceMock.GiveOutOrders invocations
func (mmGiveOutOrders *ServiceMock) GiveOutOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOutOrders.afterGiveOutOrdersCounter)
}

// GiveOutOrdersBeforeCounter returns a count of ServiceMock.GiveOutOrders invocations
func (mmGiveOutOrders *ServiceMock) GiveOutOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGiveOutOrders.beforeGiveOutOrdersCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.GiveOutOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGiveOutOrders *mServiceMockGiveOutOrders) Calls() []*ServiceMockGiveOutOrdersParams {
	mmGiveOutOrders.mutex.RLock()

	argCopy := make([]*ServiceMockGiveOutOrdersParams, len(mmGiveOutOrders.callArgs))
	copy(argCopy, mmGiveOutOrders.callArgs)

	mmGiveOutOrders.mutex.RUnlock()

	return argCopy
}

// MinimockGiveOutOrdersDone returns true if the count of the GiveOutOrders invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockGiveOutOrdersDone() bool {
	for _, e := range m.GiveOutOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOutOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGiveOutOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOutOrders != nil && mm_atomic.LoadUint64(&m.afterGiveOutOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockGiveOutOrdersInspect logs each unmet expectation
func (m *ServiceMock) MinimockGiveOutOrdersInspect() {
	for _, e := range m.GiveOutOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.GiveOutOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GiveOutOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGiveOutOrdersCounter) < 1 {
		if m.GiveOutOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.GiveOutOrders")
		} else {
			m.t.Errorf("Expected call to ServiceMock.GiveOutOrders with params: %#v", *m.GiveOutOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGiveOutOrders != nil && mm_atomic.LoadUint64(&m.afterGiveOutOrdersCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.GiveOutOrders")
	}
}

type mServiceMockListClientOrders struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockListClientOrdersExpectation
	expectations       []*ServiceMockListClientOrdersExpectation

	callArgs []*ServiceMockListClientOrdersParams
	mutex    sync.RWMutex
}

// ServiceMockListClientOrdersExpectation specifies expectation struct of the service.ListClientOrders
type ServiceMockListClientOrdersExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockListClientOrdersParams
	results *ServiceMockListClientOrdersResults
	Counter uint64
}

// ServiceMockListClientOrdersParams contains parameters of the service.ListClientOrders
type ServiceMockListClientOrdersParams struct {
	ctx context.Context
	id  uuid.UUID
}

// ServiceMockListClientOrdersResults contains results of the service.ListClientOrders
type ServiceMockListClientOrdersResults struct {
	oa1 []model.Order
	err error
}

// Expect sets up expected params for service.ListClientOrders
func (mmListClientOrders *mServiceMockListClientOrders) Expect(ctx context.Context, id uuid.UUID) *mServiceMockListClientOrders {
	if mmListClientOrders.mock.funcListClientOrders != nil {
		mmListClientOrders.mock.t.Fatalf("ServiceMock.ListClientOrders mock is already set by Set")
	}

	if mmListClientOrders.defaultExpectation == nil {
		mmListClientOrders.defaultExpectation = &ServiceMockListClientOrdersExpectation{}
	}

	mmListClientOrders.defaultExpectation.params = &ServiceMockListClientOrdersParams{ctx, id}
	for _, e := range mmListClientOrders.expectations {
		if minimock.Equal(e.params, mmListClientOrders.defaultExpectation.params) {
			mmListClientOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListClientOrders.defaultExpectation.params)
		}
	}

	return mmListClientOrders
}

// Inspect accepts an inspector function that has same arguments as the service.ListClientOrders
func (mmListClientOrders *mServiceMockListClientOrders) Inspect(f func(ctx context.Context, id uuid.UUID)) *mServiceMockListClientOrders {
	if mmListClientOrders.mock.inspectFuncListClientOrders != nil {
		mmListClientOrders.mock.t.Fatalf("Inspect function is already set for ServiceMock.ListClientOrders")
	}

	mmListClientOrders.mock.inspectFuncListClientOrders = f

	return mmListClientOrders
}

// Return sets up results that will be returned by service.ListClientOrders
func (mmListClientOrders *mServiceMockListClientOrders) Return(oa1 []model.Order, err error) *ServiceMock {
	if mmListClientOrders.mock.funcListClientOrders != nil {
		mmListClientOrders.mock.t.Fatalf("ServiceMock.ListClientOrders mock is already set by Set")
	}

	if mmListClientOrders.defaultExpectation == nil {
		mmListClientOrders.defaultExpectation = &ServiceMockListClientOrdersExpectation{mock: mmListClientOrders.mock}
	}
	mmListClientOrders.defaultExpectation.results = &ServiceMockListClientOrdersResults{oa1, err}
	return mmListClientOrders.mock
}

// Set uses given function f to mock the service.ListClientOrders method
func (mmListClientOrders *mServiceMockListClientOrders) Set(f func(ctx context.Context, id uuid.UUID) (oa1 []model.Order, err error)) *ServiceMock {
	if mmListClientOrders.defaultExpectation != nil {
		mmListClientOrders.mock.t.Fatalf("Default expectation is already set for the service.ListClientOrders method")
	}

	if len(mmListClientOrders.expectations) > 0 {
		mmListClientOrders.mock.t.Fatalf("Some expectations are already set for the service.ListClientOrders method")
	}

	mmListClientOrders.mock.funcListClientOrders = f
	return mmListClientOrders.mock
}

// When sets expectation for the service.ListClientOrders which will trigger the result defined by the following
// Then helper
func (mmListClientOrders *mServiceMockListClientOrders) When(ctx context.Context, id uuid.UUID) *ServiceMockListClientOrdersExpectation {
	if mmListClientOrders.mock.funcListClientOrders != nil {
		mmListClientOrders.mock.t.Fatalf("ServiceMock.ListClientOrders mock is already set by Set")
	}

	expectation := &ServiceMockListClientOrdersExpectation{
		mock:   mmListClientOrders.mock,
		params: &ServiceMockListClientOrdersParams{ctx, id},
	}
	mmListClientOrders.expectations = append(mmListClientOrders.expectations, expectation)
	return expectation
}

// Then sets up service.ListClientOrders return parameters for the expectation previously defined by the When method
func (e *ServiceMockListClientOrdersExpectation) Then(oa1 []model.Order, err error) *ServiceMock {
	e.results = &ServiceMockListClientOrdersResults{oa1, err}
	return e.mock
}

// ListClientOrders implements order.service
func (mmListClientOrders *ServiceMock) ListClientOrders(ctx context.Context, id uuid.UUID) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmListClientOrders.beforeListClientOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListClientOrders.afterListClientOrdersCounter, 1)

	if mmListClientOrders.inspectFuncListClientOrders != nil {
		mmListClientOrders.inspectFuncListClientOrders(ctx, id)
	}

	mm_params := ServiceMockListClientOrdersParams{ctx, id}

	// Record call args
	mmListClientOrders.ListClientOrdersMock.mutex.Lock()
	mmListClientOrders.ListClientOrdersMock.callArgs = append(mmListClientOrders.ListClientOrdersMock.callArgs, &mm_params)
	mmListClientOrders.ListClientOrdersMock.mutex.Unlock()

	for _, e := range mmListClientOrders.ListClientOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListClientOrders.ListClientOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListClientOrders.ListClientOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListClientOrders.ListClientOrdersMock.defaultExpectation.params
		mm_got := ServiceMockListClientOrdersParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListClientOrders.t.Errorf("ServiceMock.ListClientOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListClientOrders.ListClientOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListClientOrders.t.Fatal("No results are set for the ServiceMock.ListClientOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListClientOrders.funcListClientOrders != nil {
		return mmListClientOrders.funcListClientOrders(ctx, id)
	}
	mmListClientOrders.t.Fatalf("Unexpected call to ServiceMock.ListClientOrders. %v %v", ctx, id)
	return
}

// ListClientOrdersAfterCounter returns a count of finished ServiceMock.ListClientOrders invocations
func (mmListClientOrders *ServiceMock) ListClientOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListClientOrders.afterListClientOrdersCounter)
}

// ListClientOrdersBeforeCounter returns a count of ServiceMock.ListClientOrders invocations
func (mmListClientOrders *ServiceMock) ListClientOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListClientOrders.beforeListClientOrdersCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ListClientOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListClientOrders *mServiceMockListClientOrders) Calls() []*ServiceMockListClientOrdersParams {
	mmListClientOrders.mutex.RLock()

	argCopy := make([]*ServiceMockListClientOrdersParams, len(mmListClientOrders.callArgs))
	copy(argCopy, mmListClientOrders.callArgs)

	mmListClientOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListClientOrdersDone returns true if the count of the ListClientOrders invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockListClientOrdersDone() bool {
	for _, e := range m.ListClientOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListClientOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListClientOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListClientOrders != nil && mm_atomic.LoadUint64(&m.afterListClientOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockListClientOrdersInspect logs each unmet expectation
func (m *ServiceMock) MinimockListClientOrdersInspect() {
	for _, e := range m.ListClientOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ListClientOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListClientOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListClientOrdersCounter) < 1 {
		if m.ListClientOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.ListClientOrders")
		} else {
			m.t.Errorf("Expected call to ServiceMock.ListClientOrders with params: %#v", *m.ListClientOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListClientOrders != nil && mm_atomic.LoadUint64(&m.afterListClientOrdersCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.ListClientOrders")
	}
}

type mServiceMockListOrders struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockListOrdersExpectation
	expectations       []*ServiceMockListOrdersExpectation

	callArgs []*ServiceMockListOrdersParams
	mutex    sync.RWMutex
}

// ServiceMockListOrdersExpectation specifies expectation struct of the service.ListOrders
type ServiceMockListOrdersExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockListOrdersParams
	results *ServiceMockListOrdersResults
	Counter uint64
}

// ServiceMockListOrdersParams contains parameters of the service.ListOrders
type ServiceMockListOrdersParams struct {
	ctx context.Context
}

// ServiceMockListOrdersResults contains results of the service.ListOrders
type ServiceMockListOrdersResults struct {
	oa1 []model.Order
	err error
}

// Expect sets up expected params for service.ListOrders
func (mmListOrders *mServiceMockListOrders) Expect(ctx context.Context) *mServiceMockListOrders {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("ServiceMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &ServiceMockListOrdersExpectation{}
	}

	mmListOrders.defaultExpectation.params = &ServiceMockListOrdersParams{ctx}
	for _, e := range mmListOrders.expectations {
		if minimock.Equal(e.params, mmListOrders.defaultExpectation.params) {
			mmListOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListOrders.defaultExpectation.params)
		}
	}

	return mmListOrders
}

// Inspect accepts an inspector function that has same arguments as the service.ListOrders
func (mmListOrders *mServiceMockListOrders) Inspect(f func(ctx context.Context)) *mServiceMockListOrders {
	if mmListOrders.mock.inspectFuncListOrders != nil {
		mmListOrders.mock.t.Fatalf("Inspect function is already set for ServiceMock.ListOrders")
	}

	mmListOrders.mock.inspectFuncListOrders = f

	return mmListOrders
}

// Return sets up results that will be returned by service.ListOrders
func (mmListOrders *mServiceMockListOrders) Return(oa1 []model.Order, err error) *ServiceMock {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("ServiceMock.ListOrders mock is already set by Set")
	}

	if mmListOrders.defaultExpectation == nil {
		mmListOrders.defaultExpectation = &ServiceMockListOrdersExpectation{mock: mmListOrders.mock}
	}
	mmListOrders.defaultExpectation.results = &ServiceMockListOrdersResults{oa1, err}
	return mmListOrders.mock
}

// Set uses given function f to mock the service.ListOrders method
func (mmListOrders *mServiceMockListOrders) Set(f func(ctx context.Context) (oa1 []model.Order, err error)) *ServiceMock {
	if mmListOrders.defaultExpectation != nil {
		mmListOrders.mock.t.Fatalf("Default expectation is already set for the service.ListOrders method")
	}

	if len(mmListOrders.expectations) > 0 {
		mmListOrders.mock.t.Fatalf("Some expectations are already set for the service.ListOrders method")
	}

	mmListOrders.mock.funcListOrders = f
	return mmListOrders.mock
}

// When sets expectation for the service.ListOrders which will trigger the result defined by the following
// Then helper
func (mmListOrders *mServiceMockListOrders) When(ctx context.Context) *ServiceMockListOrdersExpectation {
	if mmListOrders.mock.funcListOrders != nil {
		mmListOrders.mock.t.Fatalf("ServiceMock.ListOrders mock is already set by Set")
	}

	expectation := &ServiceMockListOrdersExpectation{
		mock:   mmListOrders.mock,
		params: &ServiceMockListOrdersParams{ctx},
	}
	mmListOrders.expectations = append(mmListOrders.expectations, expectation)
	return expectation
}

// Then sets up service.ListOrders return parameters for the expectation previously defined by the When method
func (e *ServiceMockListOrdersExpectation) Then(oa1 []model.Order, err error) *ServiceMock {
	e.results = &ServiceMockListOrdersResults{oa1, err}
	return e.mock
}

// ListOrders implements order.service
func (mmListOrders *ServiceMock) ListOrders(ctx context.Context) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmListOrders.beforeListOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListOrders.afterListOrdersCounter, 1)

	if mmListOrders.inspectFuncListOrders != nil {
		mmListOrders.inspectFuncListOrders(ctx)
	}

	mm_params := ServiceMockListOrdersParams{ctx}

	// Record call args
	mmListOrders.ListOrdersMock.mutex.Lock()
	mmListOrders.ListOrdersMock.callArgs = append(mmListOrders.ListOrdersMock.callArgs, &mm_params)
	mmListOrders.ListOrdersMock.mutex.Unlock()

	for _, e := range mmListOrders.ListOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListOrders.ListOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListOrders.ListOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListOrders.ListOrdersMock.defaultExpectation.params
		mm_got := ServiceMockListOrdersParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListOrders.t.Errorf("ServiceMock.ListOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListOrders.ListOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListOrders.t.Fatal("No results are set for the ServiceMock.ListOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListOrders.funcListOrders != nil {
		return mmListOrders.funcListOrders(ctx)
	}
	mmListOrders.t.Fatalf("Unexpected call to ServiceMock.ListOrders. %v", ctx)
	return
}

// ListOrdersAfterCounter returns a count of finished ServiceMock.ListOrders invocations
func (mmListOrders *ServiceMock) ListOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.afterListOrdersCounter)
}

// ListOrdersBeforeCounter returns a count of ServiceMock.ListOrders invocations
func (mmListOrders *ServiceMock) ListOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListOrders.beforeListOrdersCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ListOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListOrders *mServiceMockListOrders) Calls() []*ServiceMockListOrdersParams {
	mmListOrders.mutex.RLock()

	argCopy := make([]*ServiceMockListOrdersParams, len(mmListOrders.callArgs))
	copy(argCopy, mmListOrders.callArgs)

	mmListOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListOrdersDone returns true if the count of the ListOrders invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockListOrdersDone() bool {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockListOrdersInspect logs each unmet expectation
func (m *ServiceMock) MinimockListOrdersInspect() {
	for _, e := range m.ListOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ListOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		if m.ListOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.ListOrders")
		} else {
			m.t.Errorf("Expected call to ServiceMock.ListOrders with params: %#v", *m.ListOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListOrders != nil && mm_atomic.LoadUint64(&m.afterListOrdersCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.ListOrders")
	}
}

type mServiceMockListReturnedOrders struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockListReturnedOrdersExpectation
	expectations       []*ServiceMockListReturnedOrdersExpectation

	callArgs []*ServiceMockListReturnedOrdersParams
	mutex    sync.RWMutex
}

// ServiceMockListReturnedOrdersExpectation specifies expectation struct of the service.ListReturnedOrders
type ServiceMockListReturnedOrdersExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockListReturnedOrdersParams
	results *ServiceMockListReturnedOrdersResults
	Counter uint64
}

// ServiceMockListReturnedOrdersParams contains parameters of the service.ListReturnedOrders
type ServiceMockListReturnedOrdersParams struct {
	ctx context.Context
}

// ServiceMockListReturnedOrdersResults contains results of the service.ListReturnedOrders
type ServiceMockListReturnedOrdersResults struct {
	oa1 []model.Order
	err error
}

// Expect sets up expected params for service.ListReturnedOrders
func (mmListReturnedOrders *mServiceMockListReturnedOrders) Expect(ctx context.Context) *mServiceMockListReturnedOrders {
	if mmListReturnedOrders.mock.funcListReturnedOrders != nil {
		mmListReturnedOrders.mock.t.Fatalf("ServiceMock.ListReturnedOrders mock is already set by Set")
	}

	if mmListReturnedOrders.defaultExpectation == nil {
		mmListReturnedOrders.defaultExpectation = &ServiceMockListReturnedOrdersExpectation{}
	}

	mmListReturnedOrders.defaultExpectation.params = &ServiceMockListReturnedOrdersParams{ctx}
	for _, e := range mmListReturnedOrders.expectations {
		if minimock.Equal(e.params, mmListReturnedOrders.defaultExpectation.params) {
			mmListReturnedOrders.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListReturnedOrders.defaultExpectation.params)
		}
	}

	return mmListReturnedOrders
}

// Inspect accepts an inspector function that has same arguments as the service.ListReturnedOrders
func (mmListReturnedOrders *mServiceMockListReturnedOrders) Inspect(f func(ctx context.Context)) *mServiceMockListReturnedOrders {
	if mmListReturnedOrders.mock.inspectFuncListReturnedOrders != nil {
		mmListReturnedOrders.mock.t.Fatalf("Inspect function is already set for ServiceMock.ListReturnedOrders")
	}

	mmListReturnedOrders.mock.inspectFuncListReturnedOrders = f

	return mmListReturnedOrders
}

// Return sets up results that will be returned by service.ListReturnedOrders
func (mmListReturnedOrders *mServiceMockListReturnedOrders) Return(oa1 []model.Order, err error) *ServiceMock {
	if mmListReturnedOrders.mock.funcListReturnedOrders != nil {
		mmListReturnedOrders.mock.t.Fatalf("ServiceMock.ListReturnedOrders mock is already set by Set")
	}

	if mmListReturnedOrders.defaultExpectation == nil {
		mmListReturnedOrders.defaultExpectation = &ServiceMockListReturnedOrdersExpectation{mock: mmListReturnedOrders.mock}
	}
	mmListReturnedOrders.defaultExpectation.results = &ServiceMockListReturnedOrdersResults{oa1, err}
	return mmListReturnedOrders.mock
}

// Set uses given function f to mock the service.ListReturnedOrders method
func (mmListReturnedOrders *mServiceMockListReturnedOrders) Set(f func(ctx context.Context) (oa1 []model.Order, err error)) *ServiceMock {
	if mmListReturnedOrders.defaultExpectation != nil {
		mmListReturnedOrders.mock.t.Fatalf("Default expectation is already set for the service.ListReturnedOrders method")
	}

	if len(mmListReturnedOrders.expectations) > 0 {
		mmListReturnedOrders.mock.t.Fatalf("Some expectations are already set for the service.ListReturnedOrders method")
	}

	mmListReturnedOrders.mock.funcListReturnedOrders = f
	return mmListReturnedOrders.mock
}

// When sets expectation for the service.ListReturnedOrders which will trigger the result defined by the following
// Then helper
func (mmListReturnedOrders *mServiceMockListReturnedOrders) When(ctx context.Context) *ServiceMockListReturnedOrdersExpectation {
	if mmListReturnedOrders.mock.funcListReturnedOrders != nil {
		mmListReturnedOrders.mock.t.Fatalf("ServiceMock.ListReturnedOrders mock is already set by Set")
	}

	expectation := &ServiceMockListReturnedOrdersExpectation{
		mock:   mmListReturnedOrders.mock,
		params: &ServiceMockListReturnedOrdersParams{ctx},
	}
	mmListReturnedOrders.expectations = append(mmListReturnedOrders.expectations, expectation)
	return expectation
}

// Then sets up service.ListReturnedOrders return parameters for the expectation previously defined by the When method
func (e *ServiceMockListReturnedOrdersExpectation) Then(oa1 []model.Order, err error) *ServiceMock {
	e.results = &ServiceMockListReturnedOrdersResults{oa1, err}
	return e.mock
}

// ListReturnedOrders implements order.service
func (mmListReturnedOrders *ServiceMock) ListReturnedOrders(ctx context.Context) (oa1 []model.Order, err error) {
	mm_atomic.AddUint64(&mmListReturnedOrders.beforeListReturnedOrdersCounter, 1)
	defer mm_atomic.AddUint64(&mmListReturnedOrders.afterListReturnedOrdersCounter, 1)

	if mmListReturnedOrders.inspectFuncListReturnedOrders != nil {
		mmListReturnedOrders.inspectFuncListReturnedOrders(ctx)
	}

	mm_params := ServiceMockListReturnedOrdersParams{ctx}

	// Record call args
	mmListReturnedOrders.ListReturnedOrdersMock.mutex.Lock()
	mmListReturnedOrders.ListReturnedOrdersMock.callArgs = append(mmListReturnedOrders.ListReturnedOrdersMock.callArgs, &mm_params)
	mmListReturnedOrders.ListReturnedOrdersMock.mutex.Unlock()

	for _, e := range mmListReturnedOrders.ListReturnedOrdersMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.oa1, e.results.err
		}
	}

	if mmListReturnedOrders.ListReturnedOrdersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListReturnedOrders.ListReturnedOrdersMock.defaultExpectation.Counter, 1)
		mm_want := mmListReturnedOrders.ListReturnedOrdersMock.defaultExpectation.params
		mm_got := ServiceMockListReturnedOrdersParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListReturnedOrders.t.Errorf("ServiceMock.ListReturnedOrders got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListReturnedOrders.ListReturnedOrdersMock.defaultExpectation.results
		if mm_results == nil {
			mmListReturnedOrders.t.Fatal("No results are set for the ServiceMock.ListReturnedOrders")
		}
		return (*mm_results).oa1, (*mm_results).err
	}
	if mmListReturnedOrders.funcListReturnedOrders != nil {
		return mmListReturnedOrders.funcListReturnedOrders(ctx)
	}
	mmListReturnedOrders.t.Fatalf("Unexpected call to ServiceMock.ListReturnedOrders. %v", ctx)
	return
}

// ListReturnedOrdersAfterCounter returns a count of finished ServiceMock.ListReturnedOrders invocations
func (mmListReturnedOrders *ServiceMock) ListReturnedOrdersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturnedOrders.afterListReturnedOrdersCounter)
}

// ListReturnedOrdersBeforeCounter returns a count of ServiceMock.ListReturnedOrders invocations
func (mmListReturnedOrders *ServiceMock) ListReturnedOrdersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListReturnedOrders.beforeListReturnedOrdersCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ListReturnedOrders.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListReturnedOrders *mServiceMockListReturnedOrders) Calls() []*ServiceMockListReturnedOrdersParams {
	mmListReturnedOrders.mutex.RLock()

	argCopy := make([]*ServiceMockListReturnedOrdersParams, len(mmListReturnedOrders.callArgs))
	copy(argCopy, mmListReturnedOrders.callArgs)

	mmListReturnedOrders.mutex.RUnlock()

	return argCopy
}

// MinimockListReturnedOrdersDone returns true if the count of the ListReturnedOrders invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockListReturnedOrdersDone() bool {
	for _, e := range m.ListReturnedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnedOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListReturnedOrdersCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturnedOrders != nil && mm_atomic.LoadUint64(&m.afterListReturnedOrdersCounter) < 1 {
		return false
	}
	return true
}

// MinimockListReturnedOrdersInspect logs each unmet expectation
func (m *ServiceMock) MinimockListReturnedOrdersInspect() {
	for _, e := range m.ListReturnedOrdersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ListReturnedOrders with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ListReturnedOrdersMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterListReturnedOrdersCounter) < 1 {
		if m.ListReturnedOrdersMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.ListReturnedOrders")
		} else {
			m.t.Errorf("Expected call to ServiceMock.ListReturnedOrders with params: %#v", *m.ListReturnedOrdersMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListReturnedOrders != nil && mm_atomic.LoadUint64(&m.afterListReturnedOrdersCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.ListReturnedOrders")
	}
}

type mServiceMockReturnOrder struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockReturnOrderExpectation
	expectations       []*ServiceMockReturnOrderExpectation

	callArgs []*ServiceMockReturnOrderParams
	mutex    sync.RWMutex
}

// ServiceMockReturnOrderExpectation specifies expectation struct of the service.ReturnOrder
type ServiceMockReturnOrderExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockReturnOrderParams
	results *ServiceMockReturnOrderResults
	Counter uint64
}

// ServiceMockReturnOrderParams contains parameters of the service.ReturnOrder
type ServiceMockReturnOrderParams struct {
	ctx      context.Context
	clientID uuid.UUID
	id       uuid.UUID
}

// ServiceMockReturnOrderResults contains results of the service.ReturnOrder
type ServiceMockReturnOrderResults struct {
	err error
}

// Expect sets up expected params for service.ReturnOrder
func (mmReturnOrder *mServiceMockReturnOrder) Expect(ctx context.Context, clientID uuid.UUID, id uuid.UUID) *mServiceMockReturnOrder {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("ServiceMock.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &ServiceMockReturnOrderExpectation{}
	}

	mmReturnOrder.defaultExpectation.params = &ServiceMockReturnOrderParams{ctx, clientID, id}
	for _, e := range mmReturnOrder.expectations {
		if minimock.Equal(e.params, mmReturnOrder.defaultExpectation.params) {
			mmReturnOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReturnOrder.defaultExpectation.params)
		}
	}

	return mmReturnOrder
}

// Inspect accepts an inspector function that has same arguments as the service.ReturnOrder
func (mmReturnOrder *mServiceMockReturnOrder) Inspect(f func(ctx context.Context, clientID uuid.UUID, id uuid.UUID)) *mServiceMockReturnOrder {
	if mmReturnOrder.mock.inspectFuncReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("Inspect function is already set for ServiceMock.ReturnOrder")
	}

	mmReturnOrder.mock.inspectFuncReturnOrder = f

	return mmReturnOrder
}

// Return sets up results that will be returned by service.ReturnOrder
func (mmReturnOrder *mServiceMockReturnOrder) Return(err error) *ServiceMock {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("ServiceMock.ReturnOrder mock is already set by Set")
	}

	if mmReturnOrder.defaultExpectation == nil {
		mmReturnOrder.defaultExpectation = &ServiceMockReturnOrderExpectation{mock: mmReturnOrder.mock}
	}
	mmReturnOrder.defaultExpectation.results = &ServiceMockReturnOrderResults{err}
	return mmReturnOrder.mock
}

// Set uses given function f to mock the service.ReturnOrder method
func (mmReturnOrder *mServiceMockReturnOrder) Set(f func(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error)) *ServiceMock {
	if mmReturnOrder.defaultExpectation != nil {
		mmReturnOrder.mock.t.Fatalf("Default expectation is already set for the service.ReturnOrder method")
	}

	if len(mmReturnOrder.expectations) > 0 {
		mmReturnOrder.mock.t.Fatalf("Some expectations are already set for the service.ReturnOrder method")
	}

	mmReturnOrder.mock.funcReturnOrder = f
	return mmReturnOrder.mock
}

// When sets expectation for the service.ReturnOrder which will trigger the result defined by the following
// Then helper
func (mmReturnOrder *mServiceMockReturnOrder) When(ctx context.Context, clientID uuid.UUID, id uuid.UUID) *ServiceMockReturnOrderExpectation {
	if mmReturnOrder.mock.funcReturnOrder != nil {
		mmReturnOrder.mock.t.Fatalf("ServiceMock.ReturnOrder mock is already set by Set")
	}

	expectation := &ServiceMockReturnOrderExpectation{
		mock:   mmReturnOrder.mock,
		params: &ServiceMockReturnOrderParams{ctx, clientID, id},
	}
	mmReturnOrder.expectations = append(mmReturnOrder.expectations, expectation)
	return expectation
}

// Then sets up service.ReturnOrder return parameters for the expectation previously defined by the When method
func (e *ServiceMockReturnOrderExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockReturnOrderResults{err}
	return e.mock
}

// ReturnOrder implements order.service
func (mmReturnOrder *ServiceMock) ReturnOrder(ctx context.Context, clientID uuid.UUID, id uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmReturnOrder.beforeReturnOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmReturnOrder.afterReturnOrderCounter, 1)

	if mmReturnOrder.inspectFuncReturnOrder != nil {
		mmReturnOrder.inspectFuncReturnOrder(ctx, clientID, id)
	}

	mm_params := ServiceMockReturnOrderParams{ctx, clientID, id}

	// Record call args
	mmReturnOrder.ReturnOrderMock.mutex.Lock()
	mmReturnOrder.ReturnOrderMock.callArgs = append(mmReturnOrder.ReturnOrderMock.callArgs, &mm_params)
	mmReturnOrder.ReturnOrderMock.mutex.Unlock()

	for _, e := range mmReturnOrder.ReturnOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmReturnOrder.ReturnOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReturnOrder.ReturnOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmReturnOrder.ReturnOrderMock.defaultExpectation.params
		mm_got := ServiceMockReturnOrderParams{ctx, clientID, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReturnOrder.t.Errorf("ServiceMock.ReturnOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReturnOrder.ReturnOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmReturnOrder.t.Fatal("No results are set for the ServiceMock.ReturnOrder")
		}
		return (*mm_results).err
	}
	if mmReturnOrder.funcReturnOrder != nil {
		return mmReturnOrder.funcReturnOrder(ctx, clientID, id)
	}
	mmReturnOrder.t.Fatalf("Unexpected call to ServiceMock.ReturnOrder. %v %v %v", ctx, clientID, id)
	return
}

// ReturnOrderAfterCounter returns a count of finished ServiceMock.ReturnOrder invocations
func (mmReturnOrder *ServiceMock) ReturnOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrder.afterReturnOrderCounter)
}

// ReturnOrderBeforeCounter returns a count of ServiceMock.ReturnOrder invocations
func (mmReturnOrder *ServiceMock) ReturnOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReturnOrder.beforeReturnOrderCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.ReturnOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReturnOrder *mServiceMockReturnOrder) Calls() []*ServiceMockReturnOrderParams {
	mmReturnOrder.mutex.RLock()

	argCopy := make([]*ServiceMockReturnOrderParams, len(mmReturnOrder.callArgs))
	copy(argCopy, mmReturnOrder.callArgs)

	mmReturnOrder.mutex.RUnlock()

	return argCopy
}

// MinimockReturnOrderDone returns true if the count of the ReturnOrder invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockReturnOrderDone() bool {
	for _, e := range m.ReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReturnOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnOrder != nil && mm_atomic.LoadUint64(&m.afterReturnOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockReturnOrderInspect logs each unmet expectation
func (m *ServiceMock) MinimockReturnOrderInspect() {
	for _, e := range m.ReturnOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.ReturnOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.ReturnOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterReturnOrderCounter) < 1 {
		if m.ReturnOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.ReturnOrder")
		} else {
			m.t.Errorf("Expected call to ServiceMock.ReturnOrder with params: %#v", *m.ReturnOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReturnOrder != nil && mm_atomic.LoadUint64(&m.afterReturnOrderCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.ReturnOrder")
	}
}

type mServiceMockUpdateOrder struct {
	mock               *ServiceMock
	defaultExpectation *ServiceMockUpdateOrderExpectation
	expectations       []*ServiceMockUpdateOrderExpectation

	callArgs []*ServiceMockUpdateOrderParams
	mutex    sync.RWMutex
}

// ServiceMockUpdateOrderExpectation specifies expectation struct of the service.UpdateOrder
type ServiceMockUpdateOrderExpectation struct {
	mock    *ServiceMock
	params  *ServiceMockUpdateOrderParams
	results *ServiceMockUpdateOrderResults
	Counter uint64
}

// ServiceMockUpdateOrderParams contains parameters of the service.UpdateOrder
type ServiceMockUpdateOrderParams struct {
	ctx    context.Context
	updPVZ model.Order
}

// ServiceMockUpdateOrderResults contains results of the service.UpdateOrder
type ServiceMockUpdateOrderResults struct {
	err error
}

// Expect sets up expected params for service.UpdateOrder
func (mmUpdateOrder *mServiceMockUpdateOrder) Expect(ctx context.Context, updPVZ model.Order) *mServiceMockUpdateOrder {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("ServiceMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &ServiceMockUpdateOrderExpectation{}
	}

	mmUpdateOrder.defaultExpectation.params = &ServiceMockUpdateOrderParams{ctx, updPVZ}
	for _, e := range mmUpdateOrder.expectations {
		if minimock.Equal(e.params, mmUpdateOrder.defaultExpectation.params) {
			mmUpdateOrder.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateOrder.defaultExpectation.params)
		}
	}

	return mmUpdateOrder
}

// Inspect accepts an inspector function that has same arguments as the service.UpdateOrder
func (mmUpdateOrder *mServiceMockUpdateOrder) Inspect(f func(ctx context.Context, updPVZ model.Order)) *mServiceMockUpdateOrder {
	if mmUpdateOrder.mock.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("Inspect function is already set for ServiceMock.UpdateOrder")
	}

	mmUpdateOrder.mock.inspectFuncUpdateOrder = f

	return mmUpdateOrder
}

// Return sets up results that will be returned by service.UpdateOrder
func (mmUpdateOrder *mServiceMockUpdateOrder) Return(err error) *ServiceMock {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("ServiceMock.UpdateOrder mock is already set by Set")
	}

	if mmUpdateOrder.defaultExpectation == nil {
		mmUpdateOrder.defaultExpectation = &ServiceMockUpdateOrderExpectation{mock: mmUpdateOrder.mock}
	}
	mmUpdateOrder.defaultExpectation.results = &ServiceMockUpdateOrderResults{err}
	return mmUpdateOrder.mock
}

// Set uses given function f to mock the service.UpdateOrder method
func (mmUpdateOrder *mServiceMockUpdateOrder) Set(f func(ctx context.Context, updPVZ model.Order) (err error)) *ServiceMock {
	if mmUpdateOrder.defaultExpectation != nil {
		mmUpdateOrder.mock.t.Fatalf("Default expectation is already set for the service.UpdateOrder method")
	}

	if len(mmUpdateOrder.expectations) > 0 {
		mmUpdateOrder.mock.t.Fatalf("Some expectations are already set for the service.UpdateOrder method")
	}

	mmUpdateOrder.mock.funcUpdateOrder = f
	return mmUpdateOrder.mock
}

// When sets expectation for the service.UpdateOrder which will trigger the result defined by the following
// Then helper
func (mmUpdateOrder *mServiceMockUpdateOrder) When(ctx context.Context, updPVZ model.Order) *ServiceMockUpdateOrderExpectation {
	if mmUpdateOrder.mock.funcUpdateOrder != nil {
		mmUpdateOrder.mock.t.Fatalf("ServiceMock.UpdateOrder mock is already set by Set")
	}

	expectation := &ServiceMockUpdateOrderExpectation{
		mock:   mmUpdateOrder.mock,
		params: &ServiceMockUpdateOrderParams{ctx, updPVZ},
	}
	mmUpdateOrder.expectations = append(mmUpdateOrder.expectations, expectation)
	return expectation
}

// Then sets up service.UpdateOrder return parameters for the expectation previously defined by the When method
func (e *ServiceMockUpdateOrderExpectation) Then(err error) *ServiceMock {
	e.results = &ServiceMockUpdateOrderResults{err}
	return e.mock
}

// UpdateOrder implements order.service
func (mmUpdateOrder *ServiceMock) UpdateOrder(ctx context.Context, updPVZ model.Order) (err error) {
	mm_atomic.AddUint64(&mmUpdateOrder.beforeUpdateOrderCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateOrder.afterUpdateOrderCounter, 1)

	if mmUpdateOrder.inspectFuncUpdateOrder != nil {
		mmUpdateOrder.inspectFuncUpdateOrder(ctx, updPVZ)
	}

	mm_params := ServiceMockUpdateOrderParams{ctx, updPVZ}

	// Record call args
	mmUpdateOrder.UpdateOrderMock.mutex.Lock()
	mmUpdateOrder.UpdateOrderMock.callArgs = append(mmUpdateOrder.UpdateOrderMock.callArgs, &mm_params)
	mmUpdateOrder.UpdateOrderMock.mutex.Unlock()

	for _, e := range mmUpdateOrder.UpdateOrderMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateOrder.UpdateOrderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateOrder.UpdateOrderMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateOrder.UpdateOrderMock.defaultExpectation.params
		mm_got := ServiceMockUpdateOrderParams{ctx, updPVZ}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateOrder.t.Errorf("ServiceMock.UpdateOrder got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateOrder.UpdateOrderMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateOrder.t.Fatal("No results are set for the ServiceMock.UpdateOrder")
		}
		return (*mm_results).err
	}
	if mmUpdateOrder.funcUpdateOrder != nil {
		return mmUpdateOrder.funcUpdateOrder(ctx, updPVZ)
	}
	mmUpdateOrder.t.Fatalf("Unexpected call to ServiceMock.UpdateOrder. %v %v", ctx, updPVZ)
	return
}

// UpdateOrderAfterCounter returns a count of finished ServiceMock.UpdateOrder invocations
func (mmUpdateOrder *ServiceMock) UpdateOrderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.afterUpdateOrderCounter)
}

// UpdateOrderBeforeCounter returns a count of ServiceMock.UpdateOrder invocations
func (mmUpdateOrder *ServiceMock) UpdateOrderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateOrder.beforeUpdateOrderCounter)
}

// Calls returns a list of arguments used in each call to ServiceMock.UpdateOrder.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateOrder *mServiceMockUpdateOrder) Calls() []*ServiceMockUpdateOrderParams {
	mmUpdateOrder.mutex.RLock()

	argCopy := make([]*ServiceMockUpdateOrderParams, len(mmUpdateOrder.callArgs))
	copy(argCopy, mmUpdateOrder.callArgs)

	mmUpdateOrder.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateOrderDone returns true if the count of the UpdateOrder invocations corresponds
// the number of defined expectations
func (m *ServiceMock) MinimockUpdateOrderDone() bool {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		return false
	}
	return true
}

// MinimockUpdateOrderInspect logs each unmet expectation
func (m *ServiceMock) MinimockUpdateOrderInspect() {
	for _, e := range m.UpdateOrderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ServiceMock.UpdateOrder with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateOrderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		if m.UpdateOrderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ServiceMock.UpdateOrder")
		} else {
			m.t.Errorf("Expected call to ServiceMock.UpdateOrder with params: %#v", *m.UpdateOrderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateOrder != nil && mm_atomic.LoadUint64(&m.afterUpdateOrderCounter) < 1 {
		m.t.Error("Expected call to ServiceMock.UpdateOrder")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateOrderInspect()

			m.MinimockDeleteOrderInspect()

			m.MinimockGetOrderByIDInspect()

			m.MinimockGiveOutOrdersInspect()

			m.MinimockListClientOrdersInspect()

			m.MinimockListOrdersInspect()

			m.MinimockListReturnedOrdersInspect()

			m.MinimockReturnOrderInspect()

			m.MinimockUpdateOrderInspect()
			m.t.FailNow()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateOrderDone() &&
		m.MinimockDeleteOrderDone() &&
		m.MinimockGetOrderByIDDone() &&
		m.MinimockGiveOutOrdersDone() &&
		m.MinimockListClientOrdersDone() &&
		m.MinimockListOrdersDone() &&
		m.MinimockListReturnedOrdersDone() &&
		m.MinimockReturnOrderDone() &&
		m.MinimockUpdateOrderDone()
}
